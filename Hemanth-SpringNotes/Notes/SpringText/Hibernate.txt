**Introduction to Hibernate**

In this section, we focus on Hibernate, a powerful tool for building applications, particularly when moving beyond simple console-based programs. While Java and JDBC suffice for console applications, and servlets or Spring MVC (built on servlets) are suitable for web or backend applications, these technologies have limitations. Spring, which we will explore later, enhances software quality and developer productivity. Similarly, Hibernate offers a significant productivity boost over plain JDBC for database operations. With JDBC, developers must perform numerous steps to store data, including manually writing SQL queries to bridge the gap between Java’s object-oriented nature and the relational structure of databases. Hibernate eliminates this burden by automating the mapping process. Additionally, Spring’s Data JPA module, which we’ll cover later, provides similar functionality, but this section focuses on understanding Hibernate and Object-Relational Mapping (ORM) for those who want to grasp its mechanics without relying on Spring Data JPA.

**What is Hibernate?**

Hibernate is an ORM framework, where ORM stands for Object-Relational Mapping. This framework addresses the mismatch between Java’s object-oriented paradigm and relational databases. In Java, everything is represented as objects, with data and methods defining entities like a person or an operation. When storing this data permanently, developers typically rely on databases rather than files for efficient processing. While both relational and NoSQL databases exist, this discussion centers on relational databases like Oracle, Postgres, or MySQL. With JDBC, storing object data in a database requires writing SQL queries, such as “INSERT INTO student” with values manually extracted from the object’s variables—a tedious and error-prone process. Hibernate simplifies this by allowing developers to save objects directly to the database without writing SQL queries. For example, a developer can instruct Hibernate to “save this object,” and it handles the rest, significantly reducing complexity.

Hibernate achieves this by understanding the object’s structure through its class, or blueprint. Consider a `Student` class with fields like roll number, name, and age. Hibernate maps this class to a database table, where the class name becomes the table name, fields become columns, and each object represents a row. The framework matches Java data types (e.g., `int`, `String`) to corresponding database types (e.g., `INTEGER`, `TEXT`) and handles naming conventions, such as converting Java’s camelCase to the database’s snake_case. Beyond simplifying data storage, Hibernate enhances productivity, maintains cleaner code, and supports features like caching and optimization. It also allows easy switching between databases (e.g., from MySQL to Postgres) without significant code changes, making it a robust choice for developers.

**Project Setup**

To demonstrate Hibernate, we’ll create a project using IntelliJ IDEA Community Edition, though the Ultimate version offers additional features. Start by creating a new Maven project named `HibProject`, using JDK 21 or higher. While a Spring project with Spring Data JPA could internally use Hibernate, this example focuses solely on Hibernate with Maven (though Gradle is also an option). After creating the project, add Hibernate and database dependencies to the `pom.xml` file. For this project, we’ll use PostgreSQL, so include the PostgreSQL driver (e.g., version 42.7.3 from March 2024) and Hibernate Core (e.g., version 6.6.3) from the Maven Repository. Reload the Maven project to download these dependencies, ensuring Hibernate and PostgreSQL libraries appear in the external libraries. Next, verify PostgreSQL is installed and accessible via pgAdmin, creating a database named `telusko` for storing data. This setup prepares the project for Hibernate configuration and database interaction.

**Failed Attempt to Save Data**

To store data, we create a `Student` class in the `com.telusko` package, representing a simple entity with fields: `rollNo` (integer), `sName` (String), and `sAge` (integer). This Plain Old Java Object (POJO) includes getters, setters, and a `toString` method. In the `Main` class, instantiate a `Student` object, set values (e.g., roll number 101, name “Navin,” age 30), and attempt to save it to the database. Unlike JDBC, which requires extensive setup, Hibernate promises a simpler approach using a `Session` object from the `org.hibernate` package. However, `Session` is an interface, so it cannot be instantiated directly. Instead, obtain a `Session` from a `SessionFactory`, which is created using a `Configuration` object. The sequence is: create a `Configuration` object, use it to build a `SessionFactory`, open a `Session`, and call `session.save(student)`.

Running this code results in a `NullPointerException` because the `SessionFactory` is null. Additionally, Hibernate lacks critical configuration details, such as the database type (PostgreSQL), username, password, and database name. These must be specified in a configuration file, as the application fails with an error: “The application must supply JDBC connections.” This highlights the need for proper configuration before Hibernate can interact with the database.

**Successful Attempt to Save Data**

To resolve the configuration issue, create a `hibernate.cfg.xml` file in the `resources` directory. Hibernate expects this file by default when `cfg.configure()` is called. The XML file includes a `hibernate-configuration` tag with a `session-factory` section, specifying properties like the PostgreSQL driver (`org.postgresql.Driver`), connection URL (`jdbc:postgresql://localhost:5432/telusko`), username (`postgres`), and password. Running the program now fails with a new error: “Unable to locate persister: com.telusko.Student.” This occurs because Hibernate doesn’t recognize the `Student` class as a database entity. Fix this by adding `cfg.addAnnotatedClass(Student.class)` before `cfg.configure()` and annotating the `Student` class with `@Entity` from `jakarta.persistence`. The `@Entity` annotation, part of the Jakarta Persistence API (JPA), marks the class for Hibernate to manage, aligning with JPA standards that ensure compatibility across ORM tools.

Another error arises: “Every entity should have an ID.” Since `rollNo` is the primary key, annotate it with `@Id`. Running the program now succeeds without errors, but checking the `telusko` database reveals no table or data. This is because saving data involves a transaction, which must be explicitly committed. Modify the code to begin a transaction (`Transaction tx = session.beginTransaction()`), save the object, and commit the transaction (`tx.commit()`). However, running this yields another error: “Relation ‘student’ does not exist,” as no table was created. To address this, add a property in `hibernate.cfg.xml`: `hibernate.hbm2ddl.auto` set to `update`. This instructs Hibernate to create the table if it doesn’t exist or use it if it does, making it ideal for development (though not recommended for production). Rerunning the program successfully creates the `student` table and saves the data, verifiable in pgAdmin.

**Show SQL Configuration**

To inspect the SQL queries Hibernate generates, add the property `hibernate.show_sql` set to `true` in `hibernate.cfg.xml`. This displays the queries in the console, such as `INSERT INTO Student` with the specified values. For better readability, add `hibernate.format_sql` set to `true`, formatting the queries clearly, which is especially useful for complex queries. Additionally, specify the database dialect with `hibernate.dialect` set to `org.hibernate.dialect.PostgreSQLDialect`. While not mandatory, this property ensures compatibility with PostgreSQL’s SQL variations, preventing potential issues. Running the program with new data (e.g., roll number 105, name “Sushil,” age 22) confirms the data is saved, and the formatted query is displayed. However, attempting to save duplicate data (e.g., same roll number) causes a “duplicate key value” error due to the primary key constraint, necessitating unique roll numbers for each record.

**Refactoring**

To optimize the code, address deprecation and resource management issues. The `session.save()` method is deprecated in Hibernate 6.0 and above, replaced by `session.persist()` to align with JPA standards. Replace `save` with `persist` to eliminate the deprecation warning. Additionally, IntelliJ flags the `SessionFactory` and `Session` for not using try-with-resources or explicit closure, as these are resource-intensive objects. Close them manually with `session.close()` and `sf.close()` after committing the transaction, or use try-with-resources for automatic closure. Finally, simplify the configuration by combining the `Configuration`, `addAnnotatedClass`, `configure`, and `buildSessionFactory` steps into a single statement: `SessionFactory sf = new Configuration().addAnnotatedClass(Student.class).configure().buildSessionFactory()`. This reduces the code to one logical statement, improving readability and maintenance. Running the refactored code with new data (e.g., roll number 106, name “Avni,” age 21) confirms successful data storage without errors or warnings, paving the way for exploring data retrieval in subsequent steps.
# Hibernate Tutorial: Comprehensive Guide to Database Operations and Mapping

This guide provides a detailed explanation of using Hibernate for database operations, including fetching, updating, deleting, customizing table and column names, embedding objects, mapping relationships, caching, and querying with Hibernate Query Language (HQL). Each concept is organized under clear side headings for easy understanding.

## Fetching Data with Hibernate

Hibernate provides methods like `get()` to fetch data from the database using a primary key. For example, to retrieve a `Student` object with roll number `102`, you can use: `Student s2 = session.get(Student.class, 102); System.out.println(s2);`. This executes a `SELECT` query and returns the object if found or `null` if not. Since fetching doesn’t modify the database, no transaction is required. To avoid `NullPointerException` when accessing a `null` object (e.g., for a non-existent roll number `109`), always check for `null`: `if (s2 != null) { System.out.println(s2.getName()); } else { System.out.println("No student found."); }`. The deprecated `load()` method uses lazy loading, fetching data only when accessed, but may throw errors like "Could not initialize proxy - no session" if the session is closed. Instead, use `get()` or `byId().getReference()` for modern Hibernate applications.

## Updating and Deleting Data

To update a record, Hibernate’s `merge()` method replaces the deprecated `update()` and `saveOrUpdate()`. For example, to update a student named Harsh (roll number `103`) with a new age of 23, create a `Student` object, set its fields, and call: `Transaction transaction = session.beginTransaction(); session.merge(s1); transaction.commit();`. This performs a `SELECT` to check for the record and an `UPDATE` to modify it, or inserts a new record if absent. A transaction is mandatory for database modifications. For deletion, use `remove()` instead of the deprecated `delete()`. To delete a student with roll number `109`, fetch or create the object and call: `session.remove(s1);` within a transaction, executing a `SELECT` followed by a `DELETE`.

## Customizing Table and Column Names

Hibernate defaults to using the class name as the table name (e.g., `Student` becomes `student`). To customize, use the `@Table` annotation, such as `@Table(name = "alien_table")` for the `Alien` class, or modify the entity name with `@Entity(name = "alien_table")`. To rename a column, apply the `@Column` annotation, like `@Column(name = "alien_name")` to map the `aname` field to `alien_name`. To exclude a field from persistence, use the `@Transient` annotation, for example: `@Transient private String technology;`, which keeps the field for processing but omits it from the database.

## Embedding Objects

For complex types within an entity, like a `Laptop` object in an `Alien`, use the `@Embeddable` annotation to embed its fields into the same table. Define a `Laptop` class with fields like `brand`, `model`, and `ram`, marked as `@Embeddable`, and include it in the `Alien` class. For example: `Laptop l1 = new Laptop(); l1.setBrand("Asus"); l1.setModel("ROG"); l1.setRam(16); Alien a1 = new Alien(); a1.setLaptop(l1); session.persist(a1);`. This stores all fields in the `alien` table, avoiding a separate `Laptop` table.

## Mapping Relationships

### One-to-One Mapping
A one-to-one relationship, where one `Alien` has one `Laptop`, uses the `@OneToOne` annotation in the `Alien` class. The `Laptop` table is the parent, with the `Alien` table containing a foreign key (`laptop_lid`). Persist the `Laptop` first, then the `Alien`: `session.persist(l1); session.persist(a1);`.

### One-to-Many and Many-to-One Mapping
In a one-to-many relationship, one `Alien` can have multiple `Laptops`, implemented with `@OneToMany` in `Alien` for a list of `Laptop` objects. To avoid a third table, use `@ManyToOne` in `Laptop` and `mappedBy` in `Alien` to delegate mapping to `Laptop`, adding an `Alien` foreign key to the `Laptop` table. For example: `l1.setAlien(a1); l2.setAlien(a1); a1.setLaptops(Arrays.asList(l1, l2)); session.persist(l1); session.persist(l2); session.persist(a1);`.

### Many-to-Many Mapping
A many-to-many relationship, where multiple `Aliens` can have multiple `Laptops`, requires `@ManyToMany` on both entities. A third table (e.g., `alien_laptop`) maps the relationships. To avoid redundant tables, use `mappedBy` in one entity, like `@ManyToMany(mappedBy = "laptops")` in `Laptop`. For example, assign multiple `Laptops` to `Aliens` and vice versa, persisting all objects: `session.persist(l1); session.persist(l2); session.persist(l3); session.persist(a1); session.persist(a2);`.

## Eager and Lazy Fetching

Hibernate supports eager and lazy fetching for collections. By default, collections use lazy fetching, where related data (e.g., `Laptops` in an `Alien`) is fetched only when accessed, reducing unnecessary queries. For example, `session.get(Alien.class, 101);` fetches only `Alien` data unless `Laptops` are accessed. To enable eager fetching, set `fetch = FetchType.EAGER` in the relationship annotation, fetching all data upfront: `@OneToMany(fetch = FetchType.EAGER)`. Lazy fetching is preferred for performance in large datasets, while eager fetching suits smaller, frequently accessed collections.

## Hibernate Caching

Hibernate provides level 1 (L1) caching by default, storing data within a session. For example, fetching an `Alien` with ID `101` twice in the same session executes one query, as the second request uses the cached data. However, different sessions don’t share L1 cache, requiring separate queries. Level 2 (L2) caching, enabled with libraries like Ehcache, allows data sharing across sessions. To implement L2 caching, add Ehcache dependencies, annotate entities with `@Cacheable`, and configure Hibernate properties like `hibernate.cache.use_second_level_cache=true`. This reduces database queries but requires careful management to handle data changes.

## Hibernate Query Language (HQL)

HQL, derived from SQL, allows querying entities and properties instead of tables and columns. For example, to fetch all `Laptop` entities: `Query query = session.createQuery("from Laptop"); List<Laptop> laptops = query.getResultList();`. To filter by a property, like `ram=32`, use: `from Laptop where ram=32`. HQL simplifies queries by omitting `SELECT *` and supports parameterized queries for dynamic values, such as: `Query query = session.createQuery("from Laptop where brand=?1"); query.setParameter(1, "Asus");`. This avoids hardcoding values and enhances security.

## Fetching with Filters and Multiple Properties

HQL supports filtering and selecting specific properties. To fetch `Laptop` models for a brand: `Query query = session.createQuery("select model from Laptop where brand=?1"); query.setParameter(1, "Asus"); List<String> models = query.getResultList();`. For multiple properties, like `brand` and `model`, HQL returns a `List<Object[]>`: `Query query = session.createQuery("select brand, model from Laptop where brand=?1"); query.setParameter(1, "Asus"); List<Object[]> results = query.getResultList();`. Iterate and cast results to access values: `for (Object[] data : results) { System.out.println(data[0] + " " + data[1]); }`. Parameterized queries use numbered placeholders (e.g., `?1`) to avoid ambiguity.

## Get vs. Load (Eager vs. Lazy Loading)

The `get()` method eagerly fetches data, executing a query immediately: `Laptop l1 = session.get(Laptop.class, 2);`. The deprecated `load()` method uses lazy loading, delaying the query until the object is accessed, which can optimize performance but risks session-related errors. The modern alternative is `byId().getReference()`: `Laptop l1 = session.byId(Laptop.class).getReference(2);`, which also supports lazy loading. For example, `get()` always queries the database, while `byId().getReference()` skips the query if the object isn’t accessed, improving efficiency for unused data.

## Level 2 Cache with Ehcache

L1 cache operates within a session, but L2 cache shares data across sessions using libraries like Ehcache. To enable L2 caching, add Ehcache and JCache dependencies to the `pom.xml`, annotate entities with `@Cacheable`, and configure Hibernate properties: `hibernate.cache.use_second_level_cache=true` and `hibernate.cache.region.factory_class=org.hibernate.cache.jcache.JCacheRegionFactory`. For example, fetching a `Laptop` in two sessions with L2 caching executes one query if cached. Ensure compatibility (e.g., Maven 3.9 requires JAXB runtime for Ehcache). L2 caching reduces database load but requires careful handling of data updates to avoid staleness.