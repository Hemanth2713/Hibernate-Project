# Hibernate 6 Tutorial: Comprehensive Notes on Database Operations and Mapping

This guide provides concise, structured notes on Hibernate 6, covering its setup, core concepts, and advanced features such as saving, fetching, updating, deleting, customizing table/column names, embedding objects, mapping relationships, caching, and querying with Hibernate Query Language (HQL). Each concept includes key points, code examples from the GitHub repository ([navinreddy20/hibernate6](https://github.com/navinreddy20/hibernate6/tree/main)), inline code explanations, relevant database tables, and diagrams where applicable. The examples use a PostgreSQL database named `telusko`. All code is embedded directly in the notes for a single, cohesive document.

---

## Introduction to Hibernate

**Key Points:**
- Hibernate is an Object-Relational Mapping (ORM) framework that simplifies database operations by mapping Java objects to relational database tables.
- It eliminates manual SQL query writing, unlike JDBC, allowing direct object persistence.
- Hibernate boosts productivity, supports clean code, caching, optimization, and easy database switching (e.g., MySQL to PostgreSQL).
- Spring Data JPA builds on Hibernate, but this guide focuses on standalone Hibernate for deeper understanding.
- Addresses the mismatch between Java’s object-oriented paradigm and relational databases, mapping classes to tables, fields to columns, and objects to rows.
- Handles data type conversions (e.g., `int` to `INTEGER`, `String` to `TEXT`) and naming conventions (camelCase to snake_case).

**Diagram: Hibernate ORM Concept**
```
[Java Object (Student)] <--> [Hibernate ORM] <--> [Database Table (student)]
  rollNo, sName, sAge                |              rollNo, s_name, s_age
```

---

## Project Setup

**Key Points:**
- Create a Maven project in IntelliJ IDEA (Community/Ultimate) with JDK 21+.
- Add Hibernate Core (6.6.3) and PostgreSQL driver (42.7.3) dependencies in `pom.xml`.
- Configure a PostgreSQL database (`telusko`) using pgAdmin.
- Set up `hibernate.cfg.xml` in the `resources` directory for database connection and Hibernate properties.

**Code Example: `pom.xml`**
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <groupId>org.example</groupId>
    <artifactId>HibProject</artifactId>
    <version>1.0-SNAPSHOT</version>

    <properties>
        <maven.compiler.source>21</maven.compiler.source>
        <maven.compiler.target>21</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <dependencies>
        <!-- Hibernate Core Dependency -->
        <dependency>
            <groupId>org.hibernate.orm</groupId>
            <artifactId>hibernate-core</artifactId>
            <version>6.6.3</version>
        </dependency>
        <!-- PostgreSQL Driver Dependency -->
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <version>42.7.3</version>
        </dependency>
    </dependencies>
</project>
```

**Code Explanation:**
- `hibernate-core`: Provides Hibernate’s ORM functionality.
- `postgresql`: JDBC driver for PostgreSQL.
- Reload Maven to download dependencies, visible in IntelliJ’s external libraries.

**Database Setup:**
| Database   | Name    | Tool   | Purpose                  |
|------------|---------|--------|--------------------------|
| PostgreSQL | telusko | pgAdmin | Store application data |

---

## Configuring Hibernate

**Key Points:**
- Create `hibernate.cfg.xml` in `resources` to configure database connection and Hibernate properties.
- Specify JDBC driver, connection URL, credentials, dialect, and settings like `show_sql`, `format_sql`, and `hbm2ddl.auto`.
- Use `update` for `hbm2ddl.auto` in development to create tables if absent or use existing ones.
- The dialect ensures compatibility with PostgreSQL’s SQL variations.

**Code Example: `hibernate.cfg.xml`**
```xml
<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE hibernate-configuration PUBLIC
        "-//Hibernate/Hibernate Configuration DTD//EN"
        "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd">
<hibernate-configuration>
    <session-factory>
        <!-- JDBC Database connection settings -->
        <property name="hibernate.connection.driver_class">org.postgresql.Driver</property>
        <property name="hibernate.connection.url">jdbc:postgresql://localhost:5432/telusko</property>
        <property name="hibernate.connection.username">postgres</property>
        <property name="hibernate.connection.password"></property>
        <!-- Specify the dialect for PostgreSQL -->
        <property name="hibernate.dialect">org.hibernate.dialect.PostgreSQLDialect</property>
        <!-- Echo the SQL to stdout -->
        <property name="hibernate.show_sql">true</property>
        <!-- Format the SQL for better readability -->
        <property name="hibernate.format_sql">true</property>
        <!-- Create or update the database schema on startup -->
        <property name="hibernate.hbm2ddl.auto">update</property>
    </session-factory>
</hibernate-configuration>
```

**Code Explanation:**
- `driver_class`: Specifies PostgreSQL JDBC driver.
- `connection.url`: Points to the `telusko` database.
- `username/password`: Database credentials (password omitted).
- `dialect`: Ensures PostgreSQL compatibility.
- `show_sql`: Displays generated SQL in the console.
- `format_sql`: Formats SQL for readability.
- `hbm2ddl.auto`: Automatically creates/updates tables.

**Diagram: Hibernate Configuration Flow**
```
[Java Application] --> [hibernate.cfg.xml] --> [SessionFactory] --> [Database (telusko)]
```

---

## Saving Data

**Key Points:**
- Create an entity class (e.g., `Student`) with `@Entity` and `@Id` annotations.
- Use `SessionFactory` and `Session` to persist objects with `session.persist()` (replaces deprecated `save()`).
- Transactions are required for database modifications (`beginTransaction()`, `commit()`).
- Handle duplicate key errors by ensuring unique primary keys.
- `hbm2ddl.auto=update` creates the table if it doesn’t exist.

**Code Example: `Student.java`**
```java
package com.telusko;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;

// Mark this class as a Hibernate entity to map to a database table
@Entity
public class Student {
    // Primary key for the Student table
    @Id
    private int rollNo;
    private String sName;
    private int sAge;

    // Getters and setters
    public int getRollNo() {
        return rollNo;
    }

    public void setRollNo(int rollNo) {
        this.rollNo = rollNo;
    }

    public String getSname() {
        return sName;
    }

    public void setSname(String sName) {
        this.sName = sName;
    }

    public int getSage() {
        return sAge;
    }

    public void setSage(int sAge) {
        this.sAge = sAge;
    }

    // toString for readable output
    @Override
    public String toString() {
        return "Student{" +
                "rollNo=" + rollNo +
                ", sName='" + sName + '\'' +
                ", sAge=" + sAge +
                '}';
    }
}
```

**Code Example: `Main.java`**
```java
package com.telusko;

import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.cfg.Configuration;

public class Main {
    public static void main(String[] args) {
        // Configure Hibernate and add the Student entity class
        SessionFactory sf = new Configuration()
                .addAnnotatedClass(Student.class)
                .configure()
                .buildSessionFactory();

        // Open a session for database operations
        try (Session session = sf.openSession()) {
            // Begin a transaction for data modification
            Transaction tx = session.beginTransaction();

            // Create a Student object and set values
            Student student = new Student();
            student.setRollNo(106);
            student.setSname("Avni");
            student.setSage(21);

            // Persist the object to the database
            session.persist(student);

            // Commit the transaction to save changes
            tx.commit();
        } finally {
            // Close the SessionFactory
            sf.close();
        }
    }
}
```

**Code Explanation:**
- `@Entity`: Marks `Student` as a database entity.
- `@Id`: Designates `rollNo` as the primary key.
- `addAnnotatedClass`: Registers `Student` with Hibernate.
- `configure()`: Loads `hibernate.cfg.xml`.
- `buildSessionFactory`: Creates a `SessionFactory`.
- `openSession`: Opens a `Session` for operations.
- `beginTransaction`: Starts a transaction.
- `persist`: Saves the `Student` object.
- `commit`: Applies changes.
- `close`: Releases resources.

**Database Table: `student`**
| rollNo (PK) | sName   | sAge |
|-------------|---------|------|
| 106         | Avni    | 21   |

---

## Fetching Data with Hibernate

**Key Points:**
- Use `session.get(Class, id)` for eager loading by primary key.
- Check for `null` to avoid `NullPointerException` for non-existent records.
- Deprecated `load()` uses lazy loading, fetching data only when accessed.
- Use `byId().getReference()` for lazy loading in modern Hibernate.
- No transaction is needed for fetching.

**Code Example: `FetchMain.java`**
```java
package com.telusko;

import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.cfg.Configuration;

public class FetchMain {
    public static void main(String[] args) {
        // Configure Hibernate and add the Student entity class
        SessionFactory sf = new Configuration()
                .addAnnotatedClass(Student.class)
                .configure()
                .buildSessionFactory();

        // Open a session for fetching data
        try (Session session = sf.openSession()) {
            // Fetch a Student object by primary key (eager loading)
            Student s2 = session.get(Student.class, 102);
            
            // Check for null to avoid NullPointerException
            if (s2 != null) {
                System.out.println(s2.getSname());
            } else {
                System.out.println("No student found with ID 102");
            }

            // Alternative: Lazy loading with byId().getReference()
            Student s3 = session.byId(Student.class).getReference(102);
            System.out.println(s3); // Query executes here due to lazy loading
        } finally {
            // Close the SessionFactory
            sf.close();
        }
    }
}
```

**Code Explanation:**
- `get(Student.class, 102)`: Eagerly fetches `Student` with `rollNo=102`.
- `null` check: Prevents errors for non-existent records.
- `byId().getReference`: Lazily loads the object, querying only when accessed.
- No transaction is used for fetching.

**Database Table: `student`**
| rollNo (PK) | sName   | sAge |
|-------------|---------|------|
| 102         | Kiran   | 20   |

---

## Updating and Deleting Data

**Key Points:**
- Use `session.merge()` to update or insert records (replaces deprecated `update()`, `saveOrUpdate()`).
- Use `session.remove()` to delete records (replaces deprecated `delete()`).
- Transactions are required for both operations.
- `merge()` performs a `SELECT` to check existence, then `UPDATE` or `INSERT`.
- `remove()` performs a `SELECT` and `DELETE`.

**Code Example: `UpdateDeleteMain.java`**
```java
package com.telusko;

import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.cfg.Configuration;

public class UpdateDeleteMain {
    public static void main(String[] args) {
        // Configure Hibernate and add the Student entity class
        SessionFactory sf = new Configuration()
                .addAnnotatedClass(Student.class)
                .configure()
                .buildSessionFactory();

        // Open a session for database operations
        try (Session session = sf.openSession()) {
            // Update example
            // Create a Student object with updated values
            Student s1 = new Student();
            s1.setRollNo(103);
            s1.setSname("Harsh");
            s1.setSage(23);

            // Begin a transaction for updating
            Transaction tx = session.beginTransaction();
            // Merge to update or insert the record
            session.merge(s1);
            // Commit the transaction
            tx.commit();

            // Delete example
            // Fetch the Student to delete
            Student s2 = session.get(Student.class, 109);
            if (s2 != null) {
                // Begin a transaction for deletion
                tx = session.beginTransaction();
                // Remove the Student from the database
                session.remove(s2);
                // Commit the transaction
                tx.commit();
            } else {
                System.out.println("No student found with ID 109");
            }
        } finally {
            // Close the SessionFactory
            sf.close();
        }
    }
}
```

**Code Explanation:**
- `merge(s1)`: Updates `Student` with `rollNo=103` or inserts if absent.
- `get(Student.class, 109)`: Fetches `Student` for deletion.
- `remove(s2)`: Deletes the fetched `Student`.
- Transactions (`beginTransaction`, `commit`) are mandatory.
- `null` check prevents errors for non-existent records.

**Database Table: `student` (After Update)**
| rollNo (PK) | sName   | sAge |
|-------------|---------|------|
| 103         | Harsh   | 23   |

---

## Customizing Table and Column Names

**Key Points:**
- Default table name is the class name (e.g., `Student` → `student`).
- Use `@Table(name="custom_name")` to customize table names.
- Use `@Column(name="custom_name")` to rename columns.
- Use `@Transient` to exclude fields from persistence.

**Code Example: `Alien.java`**
```java
package com.telusko;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import jakarta.persistence.Transient;

// Customize table name to alien_table
@Entity
@Table(name = "alien_table")
public class Alien {
    // Primary key for the table
    @Id
    private int aid;

    // Customize column name to alien_name
    @Column(name = "alien_name")
    private String aname;

    // Exclude this field from the database
    @Transient
    private String technology;

    // Getters and setters
    public int getAid() {
        return aid;
    }

    public void setAid(int aid) {
        this.aid = aid;
    }

    public String getAname() {
        return aname;
    }

    public void setAname(String aname) {
        this.aname = aname;
    }

    public String getTechnology() {
        return technology;
    }

    public void setTechnology(String technology) {
        this.technology = technology;
    }

    // toString for readable output
    @Override
    public String toString() {
        return "Alien{" +
                "aid=" + aid +
                ", aname='" + aname + '\'' +
                ", technology='" + technology + '\'' +
                '}';
    }
}
```

**Code Explanation:**
- `@Table(name="alien_table")`: Sets table name to `alien_table`.
- `@Column(name="alien_name")`: Maps `aname` to `alien_name` column.
- `@Transient`: Excludes `technology` from the database.
- `@Id`: Marks `aid` as the primary key.

**Database Table: `alien_table`**
| aid (PK) | alien_name |
|----------|------------|
| 101      | Navin      |

---

## Embedding Objects

**Key Points:**
- Use `@Embeddable` to embed an object’s fields into the parent entity’s table.
- Avoids creating a separate table for the embedded object.
- Embedded fields (e.g., `Laptop`’s `brand`, `model`, `ram`) become columns in the parent table.

**Code Example: `Laptop.java` and `AlienEmbed.java`**
```java
package com.telusko;

import jakarta.persistence.Embeddable;

// Mark this class as embeddable to include its fields in another table
@Embeddable
public class Laptop {
    private String brand;
    private String model;
    private int ram;

    // Getters and setters
    public String getBrand() {
        return brand;
    }

    public void setBrand(String brand) {
        this.brand = brand;
    }

    public String getModel() {
        return model;
    }

    public void setModel(String model) {
        this.model = model;
    }

    public int getRam() {
        return ram;
    }

    public void setRam(int ram) {
        this.ram = ram;
    }

    // toString for readable output
    @Override
    public String toString() {
        return "Laptop{" +
                "brand='" + brand + '\'' +
                ", model='" + model + '\'' +
                ", ram=" + ram +
                '}';
    }
}
```

```java
package com.telusko;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;

// Entity class with embedded Laptop object
@Entity
public class AlienEmbed {
    // Primary key for the table
    @Id
    private int aid;
    private String aname;
    private String technology;
    // Embedded Laptop object
    private Laptop laptop;

    // Getters and setters
    public int getAid() {
        return aid;
    }

    public void setAid(int aid) {
        this.aid = aid;
    }

    public String getAname() {
        return aname;
    }

    public void setAname(String aname) {
        this.aname = aname;
    }

    public String getTechnology() {
        return technology;
    }

    public void setTechnology(String technology) {
        this.technology = technology;
    }

    public Laptop getLaptop() {
        return laptop;
    }

    public void setLaptop(Laptop laptop) {
        this.laptop = laptop;
    }

    // toString for readable output
    @Override
    public String toString() {
        return "AlienEmbed{" +
                "aid=" + aid +
                ", aname='" + aname + '\'' +
                ", technology='" + technology + '\'' +
                ", laptop=" + laptop +
                '}';
    }
}
```

**Code Example: `EmbedMain.java`**
```java
package com.telusko;

import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.cfg.Configuration;

public class EmbedMain {
    public static void main(String[] args) {
        // Configure Hibernate and add the AlienEmbed entity class
        SessionFactory sf = new Configuration()
                .addAnnotatedClass(AlienEmbed.class)
                .configure()
                .buildSessionFactory();

        // Open a session for database operations
        try (Session session = sf.openSession()) {
            // Begin a transaction for data modification
            Transaction tx = session.beginTransaction();

            // Create a Laptop object
            Laptop l1 = new Laptop();
            l1.setBrand("Asus");
            l1.setModel("ROG");
            l1.setRam(16);

            // Create an AlienEmbed object with embedded Laptop
            AlienEmbed a1 = new AlienEmbed();
            a1.setAid(101);
            a1.setAname("Navin");
            a1.setTechnology("Java");
            a1.setLaptop(l1);

            // Persist the object to the database
            session.persist(a1);

            // Commit the transaction to save changes
            tx.commit();
        } finally {
            // Close the SessionFactory
            sf.close();
        }
    }
}
```

**Code Explanation:**
- `@Embeddable`: Marks `Laptop` for embedding.
- `Laptop` fields (`brand`, `model`, `ram`) are included in the `AlienEmbed` table.
- `persist(a1)`: Saves `AlienEmbed` with embedded `Laptop` fields.
- Transaction is required for persistence.

**Database Table: `alien_embed`**
| aid (PK) | aname | technology | brand | model | ram |
|----------|-------|------------|-------|-------|-----|
| 101      | Navin | Java       | Asus  | ROG   | 16  |

---

## Mapping Relationships

### One-to-One Mapping

**Key Points:**
- One `Alien` has one `Laptop`, implemented with `@OneToOne`.
- `Laptop` is the parent table; `Alien` includes a foreign key (`laptop_lid`).
- Persist the parent (`Laptop`) before the child (`Alien`).

**Code Example: `Laptop.java` and `AlienOneToOne.java`**
```java
package com.telusko;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;

// Entity class for Laptop
@Entity
public class Laptop {
    // Primary key for the table
    @Id
    private int lid;
    private String brand;
    private String model;
    private int ram;

    // Getters and setters
    public int getLid() {
        return lid;
    }

    public void setLid(int lid) {
        this.lid = lid;
    }

    public String getBrand() {
        return brand;
    }

    public void setBrand(String brand) {
        this.brand = brand;
    }

    public String getModel() {
        return model;
    }

    public void setModel(String model) {
        this.model = model;
    }

    public int getRam() {
        return ram;
    }

    public void setRam(int ram) {
        this.ram = ram;
    }

    // toString for readable output
    @Override
    public String toString() {
        return "Laptop{" +
                "lid=" + lid +
                ", brand='" + brand + '\'' +
                ", model='" + model + '\'' +
                ", ram=" + ram +
                '}';
    }
}
```

```java
package com.telusko;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.OneToOne;

// Entity class with one-to-one relationship to Laptop
@Entity
public class AlienOneToOne {
    // Primary key for the table
    @Id
    private int aid;
    private String aname;
    private String technology;
    // One-to-one relationship with Laptop
    @OneToOne
    private Laptop laptop;

    // Getters and setters
    public int getAid() {
        return aid;
    }

    public void setAid(int aid) {
        this.aid = aid;
    }

    public String getAname() {
        return aname;
    }

    public void setAname(String aname) {
        this.aname = aname;
    }

    public String getTechnology() {
        return technology;
    }

    public void setTechnology(String technology) {
        this.technology = technology;
    }

    public Laptop getLaptop() {
        return laptop;
    }

    public void setLaptop(Laptop laptop) {
        this.laptop = laptop;
    }

    // toString for readable output
    @Override
    public String toString() {
        return "AlienOneToOne{" +
                "aid=" + aid +
                ", aname='" + aname + '\'' +
                ", technology='" + technology + '\'' +
                ", laptop=" + laptop +
                '}';
    }
}
```

**Code Example: `OneToOneMain.java`**
```java
package com.telusko;

import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.cfg.Configuration;

public class OneToOneMain {
    public static void main(String[] args) {
        // Configure Hibernate and add entity classes
        SessionFactory sf = new Configuration()
                .addAnnotatedClass(AlienOneToOne.class)
                .addAnnotatedClass(Laptop.class)
                .configure()
                .buildSessionFactory();

        // Open a session for database operations
        try (Session session = sf.openSession()) {
            // Begin a transaction for data modification
            Transaction tx = session.beginTransaction();

            // Create a Laptop object
            Laptop l1 = new Laptop();
            l1.setLid(1);
            l1.setBrand("Asus");
            l1.setModel("ROG");
            l1.setRam(16);

            // Create an AlienOneToOne object with Laptop
            AlienOneToOne a1 = new AlienOneToOne();
            a1.setAid(101);
            a1.setAname("Navin");
            a1.setTechnology("Java");
            a1.setLaptop(l1);

            // Persist Laptop first (parent), then AlienOneToOne
            session.persist(l1);
            session.persist(a1);

            // Commit the transaction to save changes
            tx.commit();
        } finally {
            // Close the SessionFactory
            sf.close();
        }
    }
}
```

**Code Explanation:**
- `@OneToOne`: Defines one-to-one relationship in `AlienOneToOne`.
- `persist(l1)`: Saves `Laptop` first (parent).
- `persist(a1)`: Saves `AlienOneToOne` with foreign key to `Laptop`.
- Transaction is required.

**Database Tables:**
| Table: `laptop` |
| lid (PK) | brand | model | ram |
|----------|-------|-------|-----|
| 1        | Asus  | ROG   | 16  |

| Table: `alien_one_to_one` |
| aid (PK) | aname | technology | laptop_lid (FK) |
|----------|-------|------------|-----------------|
| 101      | Navin | Java       | 1               |

**Diagram: One-to-One Relationship**
```
[AlienOneToOne] ----(laptop_lid)----> [Laptop]
  aid, aname, technology              lid, brand, model, ram
```

### One-to-Many and Many-to-One Mapping

**Key Points:**
- One `Alien` can have multiple `Laptops`, using `@OneToMany` in `Alien`.
- Use `@ManyToOne` in `Laptop` with `mappedBy` in `Alien` to avoid a third table.
- `Laptop` table includes a foreign key to `Alien`.

**Code Example: `LaptopMany.java` and `AlienOneToMany.java`**
```java
package com.telusko;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.ManyToOne;

// Entity class with many-to-one relationship to Alien
@Entity
public class LaptopMany {
    // Primary key for the table
    @Id
    private int lid;
    private String brand;
    private String model;
    private int ram;
    // Many-to-one relationship with Alien
    @ManyToOne
    private AlienOneToMany alien;

    // Getters and setters
    public int getLid() {
        return lid;
    }

    public void setLid(int lid) {
        this.lid = lid;
    }

    public String getBrand() {
        return brand;
    }

    public void setBrand(String brand) {
        this.brand = brand;
    }

    public String getModel() {
        return model;
    }

    public void setModel(String model) {
        this.model = model;
    }

    public int getRam() {
        return ram;
    }

    public void setRam(int ram) {
        this.ram = ram;
    }

    public AlienOneToMany getAlien() {
        return alien;
    }

    public void setAlien(AlienOneToMany alien) {
        this.alien = alien;
    }

    // toString for readable output
    @Override
    public String toString() {
        return "LaptopMany{" +
                "lid=" + lid +
                ", brand='" + brand + '\'' +
                ", model='" + model + '\'' +
                ", ram=" + ram +
                '}';
    }
}
```

```java
package com.telusko;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.OneToMany;

import java.util.ArrayList;
import java.util.List;

// Entity class with one-to-many relationship to Laptop
@Entity
public class AlienOneToMany {
    // Primary key for the table
    @Id
    private int aid;
    private String aname;
    private String technology;
    // One-to-many relationship with Laptop
    @OneToMany(mappedBy = "alien")
    private List<LaptopMany> laptops = new ArrayList<>();

    // Getters and setters
    public int getAid() {
        return aid;
    }

    public void setAid(int aid) {
        this.aid = aid;
    }

    public String getAname() {
        return aname;
    }

    public void setAname(String aname) {
        this.aname = aname;
    }

    public String getTechnology() {
        return technology;
    }

    public void setTechnology(String technology) {
        this.technology = technology;
    }

    public List<LaptopMany> getLaptops() {
        return laptops;
    }

    public void setLaptops(List<LaptopMany> laptops) {
        this.laptops = laptops;
    }

    // toString for readable output
    @Override
    public String toString() {
        return "AlienOneToMany{" +
                "aid=" + aid +
                ", aname='" + aname + '\'' +
                ", technology='" + technology + '\'' +
                ", laptops=" + laptops +
                '}';
    }
}
```

**Code Example: `OneToManyMain.java`**
```java
package com.telusko;

import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.cfg.Configuration;

import java.util.Arrays;

public class OneToManyMain {
    public static void main(String[] args) {
        // Configure Hibernate and add entity classes
        SessionFactory sf = new Configuration()
                .addAnnotatedClass(AlienOneToMany.class)
                .addAnnotatedClass(LaptopMany.class)
                .configure()
                .buildSessionFactory();

        // Open a session for database operations
        try (Session session = sf.openSession()) {
            // Begin a transaction for data modification
            Transaction tx = session.beginTransaction();

            // Create Laptop objects
            LaptopMany l1 = new LaptopMany();
            l1.setLid(1);
            l1.setBrand("Asus");
            l1.setModel("ROG");
            l1.setRam(16);

            LaptopMany l2 = new LaptopMany();
            l2.setLid(2);
            l2.setBrand("Dell");
            l2.setModel("XPS");
            l2.setRam(32);

            // Create an AlienOneToMany object
            AlienOneToMany a1 = new AlienOneToMany();
            a1.setAid(101);
            a1.setAname("Navin");
            a1.setTechnology("Java");

            // Set relationships
            l1.setAlien(a1);
            l2.setAlien(a1);
            a1.setLaptops(Arrays.asList(l1, l2));

            // Persist Laptops and Alien
            session.persist(l1);
            session.persist(l2);
            session.persist(a1);

            // Commit the transaction to save changes
            tx.commit();
        } finally {
            // Close the SessionFactory
            sf.close();
        }
    }
}
```

**Code Explanation:**
- `@OneToMany(mappedBy="alien")`: Defines one-to-many in `AlienOneToMany`.
- `@ManyToOne`: Links `LaptopMany` to `AlienOneToMany`.
- `mappedBy`: Delegates mapping to `LaptopMany`, adding `alien_aid` foreign key.
- Persist `LaptopMany` objects before `AlienOneToMany`.

**Database Tables:**
| Table: `laptop_many` |
| lid (PK) | brand | model | ram | alien_aid (FK) |
|----------|-------|-------|-----|----------------|
| 1        | Asus  | ROG   | 16  | 101            |
| 2        | Dell  | XPS   | 32  | 101            |

| Table: `alien_one_to_many` |
| aid (PK) | aname | technology |
|----------|-------|------------|
| 101      | Navin | Java       |

**Diagram: One-to-Many Relationship**
```
[AlienOneToMany] <----(alien_aid)---- [LaptopMany]
  aid, aname, technology               lid, brand, model, ram
```

### Many-to-Many Mapping

**Key Points:**
- Multiple `Aliens` can have multiple `Laptops`, using `@ManyToMany`.
- Creates a third table (e.g., `alien_laptop`) for relationships.
- Use `mappedBy` to avoid redundant tables.

**Code Example: `LaptopManyToMany.java` and `AlienManyToMany.java`**
```java
package com.telusko;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.ManyToMany;

import java.util.ArrayList;
import java.util.List;

// Entity class with many-to-many relationship to Alien
@Entity
public class LaptopManyToMany {
    // Primary key for the table
    @Id
    private int lid;
    private String brand;
    private String model;
    private int ram;
    // Many-to-many relationship with Alien
    @ManyToMany
    private List<AlienManyToMany> aliens = new ArrayList<>();

    // Getters and setters
    public int getLid() {
        return lid;
    }

    public void setLid(int lid) {
        this.lid = lid;
    }

    public String getBrand() {
        return brand;
    }

    public void setBrand(String brand) {
        this.brand = brand;
    }

    public String getModel() {
        return model;
    }

    public void setModel(String model) {
        this.model = model;
    }

    public int getRam() {
        return ram;
    }

    public void setRam(int ram) {
        this.ram = ram;
    }

    public List<AlienManyToMany> getAliens() {
        return aliens;
    }

    public void setAliens(List<AlienManyToMany> aliens) {
        this.aliens = aliens;
    }

    // toString for readable output
    @Override
    public String toString() {
        return "LaptopManyToMany{" +
                "lid=" + lid +
                ", brand='" + brand + '\'' +
                ", model='" + model + '\'' +
                ", ram=" + ram +
                '}';
    }
}
```

```java
package com.telusko;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.ManyToMany;

import java.util.ArrayList;
import java.util.List;

// Entity class with many-to-many relationship to Laptop
@Entity
public class AlienManyToMany {
    // Primary key for the table
    @Id
    private int aid;
    private String aname;
    private String technology;
    // Many-to-many relationship with Laptop
    @ManyToMany(mappedBy = "aliens")
    private List<LaptopManyToMany> laptops = new ArrayList<>();

    // Getters and setters
    public int getAid() {
        return aid;
    }

    public void setAid(int aid) {
        this.aid = aid;
    }

    public String getAname() {
        return aname;
    }

    public void setAname(String aname) {
        this.aname = aname;
    }

    public String getTechnology() {
        return technology;
    }

    public void setTechnology(String technology) {
        this.technology = technology;
    }

    public List<LaptopManyToMany> getLaptops() {
        return laptops;
    }

    public void setLaptops(List<LaptopManyToMany> laptops) {
        this.laptops = laptops;
    }

    // toString for readable output
    @Override
    public String toString() {
        return "AlienManyToMany{" +
                "aid=" + aid +
                ", aname='" + aname + '\'' +
                ", technology='" + technology + '\'' +
                ", laptops=" + laptops +
                '}';
    }
}
```

**Code Example: `ManyToManyMain.java`**
```java
package com.telusko;

import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.cfg.Configuration;

import java.util.Arrays;

public class ManyToManyMain {
    public static void main(String[] args) {
        // Configure Hibernate and add entity classes
        SessionFactory sf = new Configuration()
                .addAnnotatedClass(AlienManyToMany.class)
                .addAnnotatedClass(LaptopManyToMany.class)
                .configure()
                .buildSessionFactory();

        // Open a session for database operations
        try (Session session = sf.openSession()) {
            // Begin a transaction for data modification
            Transaction tx = session.beginTransaction();

            // Create Laptop objects
            LaptopManyToMany l1 = new LaptopManyToMany();
            l1.setLid(1);
            l1.setBrand("Asus");
            l1.setModel("ROG");
            l1.setRam(16);

            LaptopManyToMany l2 = new LaptopManyToMany();
            l2.setLid(2);
            l2.setBrand("Dell");
            l2.setModel("XPS");
            l2.setRam(32);

            LaptopManyToMany l3 = new LaptopManyToMany();
            l3.setLid(3);
            l3.setBrand("HP");
            l3.setModel("Spectre");
            l3.setRam(8);

            // Create Alien objects
            AlienManyToMany a1 = new AlienManyToMany();
            a1.setAid(101);
            a1.setAname("Navin");
            a1.setTechnology("Java");

            AlienManyToMany a2 = new AlienManyToMany();
            a2.setAid(102);
            a2.setAname("Kiran");
            a2.setTechnology("Python");

            // Set relationships
            l1.setAliens(Arrays.asList(a1, a2));
            l2.setAliens(Arrays.asList(a1));
            l3.setAliens(Arrays.asList(a2));
            a1.setLaptops(Arrays.asList(l1, l2));
            a2.setLaptops(Arrays.asList(l1, l3));

            // Persist all objects
            session.persist(l1);
            session.persist(l2);
            session.persist(l3);
            session.persist(a1);
            session.persist(a2);

            // Commit the transaction to save changes
            tx.commit();
        } finally {
            // Close the SessionFactory
            sf.close();
        }
    }
}
```

**Code Explanation:**
- `@ManyToMany`: Defines many-to-many in both entities.
- `mappedBy="aliens"`: Delegates mapping to `LaptopManyToMany`.
- Creates `alien_many_to_many_laptop_many_to_many` table for relationships.
- Persist all objects with transaction.

**Database Tables:**
| Table: `laptop_many_to_many` |
| lid (PK) | brand | model   | ram |
|----------|-------|---------|-----|
| 1        | Asus  | ROG     | 16  |
| 2        | Dell  | XPS     | 32  |
| 3        | HP    | Spectre | 8   |

| Table: `alien_many_to_many` |
| aid (PK) | aname | technology |
|----------|-------|------------|
| 101      | Navin | Java       |
| 102      | Kiran | Python     |

| Table: `alien_many_to_many_laptop_many_to_many` |
| aliens_aid (FK) | laptops_lid (FK) |
|-----------------|------------------|
| 101             | 1                |
| 101             | 2                |
| 102             | 1                |
| 102             | 3                |

**Diagram: Many-to-Many Relationship**
```
[AlienManyToMany] <--> [alien_many_to_many_laptop_many_to_many] <--> [LaptopManyToMany]
  aid, aname, technology        aliens_aid, laptops_lid            lid, brand, model, ram
```

---

## Eager and Lazy Fetching

**Key Points:**
- Default: Collections use lazy fetching, loading related data only when accessed.
- Use `fetch = FetchType.EAGER` for immediate loading of related data.
- Lazy fetching improves performance for large datasets; eager fetching suits small, frequently accessed data.

**Code Example: `AlienOneToMany.java` (Modified)**
```java
package com.telusko;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.OneToMany;
import jakarta.persistence.FetchType;

import java.util.ArrayList;
import java.util.List;

// Entity class with one-to-many relationship to Laptop
@Entity
public class AlienOneToMany {
    // Primary key for the table
    @Id
    private int aid;
    private String aname;
    private String technology;
    // One-to-many with eager fetching
    @OneToMany(mappedBy = "alien", fetch = FetchType.EAGER)
    private List<LaptopMany> laptops = new ArrayList<>();

    // Getters and setters
    public int getAid() {
        return aid;
    }

    public void setAid(int aid) {
        this.aid = aid;
    }

    public String getAname() {
        return aname;
    }

    public void setAname(String aname) {
        this.aname = aname;
    }

    public String getTechnology() {
        return technology;
    }

    public void setTechnology(String technology) {
        this.technology = technology;
    }

    public List<LaptopMany> getLaptops() {
        return laptops;
    }

    public void setLaptops(List<LaptopMany> laptops) {
        this.laptops = laptops;
    }

    // toString for readable output
    @Override
    public String toString() {
        return "AlienOneToMany{" +
                "aid=" + aid +
                ", aname='" + aname + '\'' +
                ", technology='" + technology + '\'' +
                ", laptops=" + laptops +
                '}';
    }
}
```

**Code Example: `FetchEagerMain.java`**
```java
package com.telusko;

import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.cfg.Configuration;

public class FetchEagerMain {
    public static void main(String[] args) {
        // Configure Hibernate and add entity classes
        SessionFactory sf = new Configuration()
                .addAnnotatedClass(AlienOneToMany.class)
                .addAnnotatedClass(LaptopMany.class)
                .configure()
                .buildSessionFactory();

        // Open a session for fetching data
        try (Session session = sf.openSession()) {
            // Fetch Alien with eager loading of Laptops
            AlienOneToMany a1 = session.get(AlienOneToMany.class, 101);
            System.out.println(a1); // Laptops are fetched immediately
        } finally {
            // Close the SessionFactory
            sf.close();
        }
    }
}
```

**Code Explanation:**
- `fetch = FetchType.EAGER`: Loads `Laptops` with `AlienOneToMany`.
- `get(AlienOneToMany.class, 101)`: Fetches `Alien` and its `Laptops` in one query.
- Lazy fetching (default) would delay `Laptops` loading until accessed.

---

## Hibernate Caching

**Key Points:**
- **Level 1 (L1) Cache**: Default, session-scoped; fetching the same object twice in a session uses the cache.
- **Level 2 (L2) Cache**: Optional, session-factory-scoped; shares data across sessions using libraries like Ehcache.
- L2 requires `@Cacheable` and configuration (e.g., `hibernate.cache.use_second_level_cache=true`).
- Caching reduces database queries but needs careful management for data consistency.

**Code Example: `Laptop.java` (Modified for L2 Cache)**
```java
package com.telusko;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Cacheable;
import org.hibernate.annotations.Cache;
import org.hibernate.annotations.CacheConcurrencyStrategy;

// Entity class with L2 caching enabled
@Entity
@Cacheable
@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
public class Laptop {
    // Primary key for the table
    @Id
    private int lid;
    private String brand;
    private String model;
    private int ram;

    // Getters and setters
    public int getLid() {
        return lid;
    }

    public void setLid(int lid) {
        this.lid = lid;
    }

    public String getBrand() {
        return brand;
    }

    public void setBrand(String brand) {
        this.brand = brand;
    }

    public String getModel() {
        return model;
    }

    public void setModel(String model) {
        this.model = model;
    }

    public int getRam() {
        return ram;
    }

    public void setRam(int ram) {
        this.ram = ram;
    }

    // toString for readable output
    @Override
    public String toString() {
        return "Laptop{" +
                "lid=" + lid +
                ", brand='" + brand + '\'' +
                ", model='" + model + '\'' +
                ", ram=" + ram +
                '}';
    }
}
```

**Code Example: `CacheMain.java`**
```java
package com.telusko;

import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.cfg.Configuration;

public class CacheMain {
    public static void main(String[] args) {
        // Configure Hibernate and add entity class
        SessionFactory sf = new Configuration()
                .addAnnotatedClass(Laptop.class)
                .configure()
                .buildSessionFactory();

        // First session: L1 cache
        try (Session session1 = sf.openSession()) {
            // Fetch Laptop (queries database)
            Laptop l1 = session1.get(Laptop.class, 1);
            System.out.println(l1);

            // Fetch again in same session (uses L1 cache)
            Laptop l2 = session1.get(Laptop.class, 1);
            System.out.println(l2);
        }

        // Second session: L2 cache (if enabled)
        try (Session session2 = sf.openSession()) {
            // Fetch Laptop (uses L2 cache if configured)
            Laptop l3 = session2.get(Laptop.class, 1);
            System.out.println(l3);
        } finally {
            // Close the SessionFactory
            sf.close();
        }
    }
}
```

**Code Example: `pom.xml` (L2 Cache Dependencies)**
```xml
<dependencies>
    <!-- Existing dependencies -->
    <dependency>
        <groupId>org.hibernate.orm</groupId>
        <artifactId>hibernate-core</artifactId>
        <version>6.6.3</version>
    </dependency>
    <dependency>
        <groupId>org.postgresql</groupId>
        <artifactId>postgresql</artifactId>
        <version>42.7.3</version>
    </dependency>
    <!-- Ehcache for L2 caching -->
    <dependency>
        <groupId>org.hibernate</groupId>
        <artifactId>hibernate-jcache</artifactId>
        <version>6.6.3</version>
    </dependency>
    <dependency>
        <groupId>org.ehcache</groupId>
        <artifactId>ehcache</artifactId>
        <version>3.10.8</version>
    </dependency>
</dependencies>
```

**Code Example: `hibernate.cfg.xml` (L2 Cache Configuration)**
```xml
<hibernate-configuration>
    <session-factory>
        <!-- Existing properties -->
        <property name="hibernate.connection.driver_class">org.postgresql.Driver</property>
        <property name="hibernate.connection.url">jdbc:postgresql://localhost:5432/telusko</property>
        <property name="hibernate.connection.username">postgres</property>
        <property name="hibernate.connection.password"></property>
        <property name="hibernate.dialect">org.hibernate.dialect.PostgreSQLDialect</property>
        <property name="hibernate.show_sql">true</property>
        <property name="hibernate.format_sql">true</property>
        <property name="hibernate.hbm2ddl.auto">update</property>
        <!-- L2 cache settings -->
        <property name="hibernate.cache.use_second_level_cache">true</property>
        <property name="hibernate.cache.region.factory_class">org.hibernate.cache.jcache.JCacheRegionFactory</property>
    </session-factory>
</hibernate-configuration>
```

**Code Explanation:**
- `@Cacheable` and `@Cache`: Enable L2 caching for `Laptop`.
- `hibernate.cache.use_second_level_cache`: Activates L2 cache.
- `JCacheRegionFactory`: Uses Ehcache for caching.
- L1 cache: `l1` and `l2` in `session1` use the same query.
- L2 cache: `l3` in `session2` uses cached data if configured.

**Database Table: `laptop`**
| lid (PK) | brand | model | ram |
|----------|-------|-------|-----|
| 1        | Asus  | ROG   | 16  |

---

## Hibernate Query Language (HQL)

**Key Points:**
- HQL queries entities and properties, not tables/columns, unlike SQL.
- Use `session.createQuery()` to execute HQL queries.
- Supports filtering, parameterized queries, and selecting specific properties.
- Parameterized queries use `?1`, `?2`, etc., for dynamic values.

**Code Example: `HQLMain.java`**
```java
package com.telusko;

import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.cfg.Configuration;
import org.hibernate.query.Query;

import java.util.List;

public class HQLMain {
    public static void main(String[] args) {
        // Configure Hibernate and add entity class
        SessionFactory sf = new Configuration()
                .addAnnotatedClass(Laptop.class)
                .configure()
                .buildSessionFactory();

        // Open a session for querying
        try (Session session = sf.openSession()) {
            // Fetch all Laptops
            Query<Laptop> query1 = session.createQuery("from Laptop", Laptop.class);
            List<Laptop> laptops = query1.getResultList();
            System.out.println("All Laptops: " + laptops);

            // Filter by ram
            Query<Laptop> query2 = session.createQuery("from Laptop where ram = ?1", Laptop.class);
            query2.setParameter(1, 32);
            laptops = query2.getResultList();
            System.out.println("Laptops with 32GB RAM: " + laptops);

            // Select specific property (model)
            Query<String> query3 = session.createQuery("select model from Laptop where brand = ?1", String.class);
            query3.setParameter(1, "Asus");
            List<String> models = query3.getResultList();
            System.out.println("Asus Models: " + models);

            // Select multiple properties (brand, model)
            Query<Object[]> query4 = session.createQuery("select brand, model from Laptop where brand = ?1", Object[].class);
            query4.setParameter(1, "Asus");
            List<Object[]> results = query4.getResultList();
            for (Object[] data : results) {
                System.out.println("Brand: " + data[0] + ", Model: " + data[1]);
            }
        } finally {
            // Close the SessionFactory
            sf.close();
        }
    }
}
```

**Code Explanation:**
- `from Laptop`: Fetches all `Laptop` entities.
- `where ram = ?1`: Filters by `ram` using parameterized query.
- `select model`: Retrieves only the `model` property.
- `select brand, model`: Returns `List<Object[]>` with multiple properties.
- No transaction is needed for queries.

**Database Table: `laptop`**
| lid (PK) | brand | model   | ram |
|----------|-------|---------|-----|
| 1        | Asus  | ROG     | 16  |
| 2        | Dell  | XPS     | 32  |

---

## Fetching with Filters and Multiple Properties

**Key Points:**
- HQL supports filtering with `where` clauses and selecting specific properties.
- Single property queries return `List<T>`; multiple properties return `List<Object[]>`.
- Use parameterized queries (`?1`) for security and flexibility.

**Code Explanation (from `HQLMain.java` above):**
- `select model from Laptop where brand = ?1`: Returns `List<String>` of models for `Asus`.
- `select brand, model from Laptop where brand = ?1`: Returns `List<Object[]>` with brand and model.
- Iterate `Object[]` and cast to access values.

**Output Example:**
```
Asus Models: [ROG]
Brand: Asus, Model: ROG
```

---

## Get vs. Load (Eager vs. Lazy Loading)

**Key Points:**
- `get()`: Eagerly fetches data, querying immediately.
- Deprecated `load()`: Lazily fetches data, querying when accessed.
- `byId().getReference()`: Modern lazy loading alternative.
- Lazy loading optimizes performance but risks session errors if closed.

**Code Example: `GetVsLoadMain.java`**
```java
package com.telusko;

import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.cfg.Configuration;

public class GetVsLoadMain {
    public static void main(String[] args) {
        // Configure Hibernate and add entity class
        SessionFactory sf = new Configuration()
                .addAnnotatedClass(Laptop.class)
                .configure()
                .buildSessionFactory();

        // Open a session for fetching
        try (Session session = sf.openSession()) {
            // Eager loading with get
            Laptop l1 = session.get(Laptop.class, 2); // Queries immediately
            System.out.println(l1);

            // Lazy loading with byId().getReference
            Laptop l2 = session.byId(Laptop.class).getReference(2); // No query yet
            System.out.println(l2); // Queries when accessed
        } finally {
            // Close the SessionFactory
            sf.close();
        }
    }
}
```

**Code Explanation:**
- `get(Laptop.class, 2)`: Executes query immediately.
- `byId().getReference(2)`: Delays query until `l2` is accessed.
- Lazy loading skips queries for unused objects.

**Database Table: `laptop`**
| lid (PK) | brand | model | ram |
|----------|-------|-------|-----|
| 2        | Dell  | XPS   | 32  |

---

## Level 2 Cache with Ehcache

**Key Points:**
- L1 cache: Session-scoped, default in Hibernate.
- L2 cache: Session-factory-scoped, enabled with Ehcache and `@Cacheable`.
- Configure L2 cache in `hibernate.cfg.xml` and `pom.xml`.
- Reduces database queries but requires careful data update handling.

**Code Explanation (from `CacheMain.java` and configurations above):**
- `@Cacheable` and `@Cache`: Enable L2 caching for `Laptop`.
- `hibernate.cache.use_second_level_cache`: Activates L2 cache.
- `JCacheRegionFactory`: Uses Ehcache.
- L2 cache shares `Laptop` data across sessions.

**Dependencies and Configuration (Already Shown Above):**
- Ehcache and `hibernate-jcache` in `pom.xml`.
- L2 cache properties in `hibernate.cfg.xml`.

**Diagram: Caching Levels**
```
[L1 Cache (Session)] --> [L2 Cache (SessionFactory)] --> [Database (telusko)]
  Per-session data         Shared across sessions        Persistent storage
```

---

This comprehensive guide covers all Hibernate 6 concepts with practical examples, ensuring a deep understanding of ORM, database operations, and advanced features.