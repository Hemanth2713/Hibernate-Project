<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>REST API Notes for Beginners</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 20px;
        background-color: #f1f1f1;
        line-height: 1.6;
        transition: background-color 0.3s, color 0.3s;
      }
      .white-bg {
        background-color: #ffffff;
        color: #333;
      }
      .grey-bg {
        background-color: #e0e0e0;
        color: #333;
      }
      .black-bg {
        background-color: #1a1a1a;
        color: #ffffff;
      }
      .bg-switcher {
        position: fixed;
        top: 10px;
        right: 10px;
        z-index: 1000;
        font-size: 16px;
      }
      .bg-switcher label {
        margin-right: 10px;
        color: inherit;
      }
      .bg-switcher select {
        padding: 5px;
        border-radius: 5px;
        background-color: #04aa6d;
        color: white;
        border: none;
        cursor: pointer;
      }
      .bg-switcher select:focus {
        outline: 2px solid #059862;
      }
      .sidebar {
        width: 250px;
        background-color: #04aa6d;
        position: fixed;
        top: 0;
        left: 0;
        height: 100%;
        padding-top: 20px;
        color: white;
        overflow-y: auto;
      }
      .sidebar-title {
        font-size: 24px;
        text-align: center;
        margin-bottom: 30px;
      }
      .sidebar-link {
        display: block;
        padding: 12px 20px;
        color: white;
        text-decoration: none;
        font-size: 18px;
        transition: background-color 0.3s;
      }
      .sidebar-link:hover {
        background-color: #059862;
      }
      .sidebar-link:focus {
        outline: 2px solid white;
      }
      .main-content {
        margin-left: 270px;
        padding: 30px;
      }
      .header {
        background-color: #282a35;
        color: white;
        padding: 20px;
        text-align: center;
        border-radius: 8px;
        margin-bottom: 20px;
      }
      .header-title {
        font-size: 36px;
        margin: 0;
      }
      .header-subtitle {
        font-size: 18px;
        margin-top: 10px;
      }
      .section {
        margin: 20px 0;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      }
      .white-bg .section {
        background-color: #f9f9f9;
      }
      .grey-bg .section {
        background-color: #d0d0d0;
      }
      .black-bg .section {
        background-color: #2a2a2a;
      }
      .section-title {
        font-size: 28px;
        color: #04aa6d;
        margin-bottom: 15px;
      }
      .subsection-title {
        font-size: 22px;
        margin: 15px 0 10px;
        color: inherit;
      }
      table {
        width: 100%;
        border-collapse: collapse;
        margin-bottom: 20px;
        background-color: #ffffff;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        overflow-x: auto;
      }
      th,
      td {
        padding: 12px 15px;
        text-align: left;
        border-bottom: 1px solid #ddd;
      }
      th {
        background-color: #04aa6d;
        color: white;
        font-weight: bold;
      }
      td {
        background-color: #000000;
        color: #ffffff;
      }
      tr:nth-child(even) {
        background-color: #f9f9f9;
      }
      tr:hover {
        background-color: #f1f1f1;
      }
      .content-line {
        font-size: 16px;
        margin: 8px 0;
        padding: 10px;
        border-left: 4px solid #04aa6d;
      }
      .content-line.black-highlight {
        border-left: 4px solid #000000;
      }
      .white-bg .content-line {
        background-color: #f0f0f0;
      }
      .grey-bg .content-line {
        background-color: #c0c0c0;
      }
      .black-bg .content-line {
        background-color: #333333;
      }
      .code-block {
        padding: 15px;
        border-radius: 5px;
        font-family: "Courier New", Courier, monospace;
        font-size: 16px;
        overflow-x: auto;
        margin: 10px 0;
        background-color: #282a35;
        color: white;
      }
      .code-block::-webkit-scrollbar {
        height: 8px;
      }
      .code-block::-webkit-scrollbar-thumb {
        background-color: #04aa6d;
        border-radius: 4px;
      }
      .code-block::-webkit-scrollbar-track {
        background-color: #f1f1f1;
      }
      /* Syntax highlighting styles */
      .keyword-highlight {
        color: #ffa500;
        font-size: 16px;
      } /* Orange for keywords */
      .string-highlight {
        color: #00ff00;
      } /* Green for strings */
      .comment-highlight {
        color: #808080;
      } /* Grey for comments */
      .class-highlight {
        color: #00ced1;
      } /* Cyan for class names */
      .annotation-highlight {
        color: #c71585;
      } /* Purple for annotations */
      /* JSON syntax highlighting */
      .code-block .json-key {
        color: #f8c555;
      } /* yellow-orange */
      .code-block .json-string {
        color: #9cdcfe;
      } /* light blue */
      .code-block .json-number {
        color: #b5cea8;
      } /* greenish */
      .code-block .json-boolean {
        color: #c586c0;
      } /* purple */
      .code-block .json-null {
        color: #d16969;
      } /* reddish-pink */
      /* XML syntax highlighting for pom.xml */
      .code-block .xml-element {
        color: #c586c0;
      } /* purple */
      .code-block .xml-attribute {
        color: #f8c555;
      } /* yellow-orange */
      .code-block .xml-value {
        color: #9cdcfe;
      } /* light blue */
      .code-block .xml-comment {
        color: #6a9955;
        font-style: italic;
      } /* greenish */
      /* Properties file syntax highlighting for application.properties */
      .code-block .prop-key {
        color: #f8c555;
      } /* yellow-orange, matching json-key */
      .code-block .prop-value {
        color: #9cdcfe;
      } /* light blue, matching json-string */
      .code-block .prop-comment {
        color: #6a9955;
        font-style: italic;
      } /* greenish, matching xml-comment */
      .highlight {
        color: #ff4500;
        font-weight: bold;
      }
      strong {
        font-weight: bold;
      }
      .code-heading {
        color: #000000;
        font-weight: bold;
        font-size: 16px;
      }
      a {
        color: #04aa6d;
        text-decoration: none;
      }
      a:hover {
        text-decoration: underline;
      }
      ul,
      ol {
        margin: 10px 0;
        padding-left: 20px;
      }
      li {
        margin: 5px 0;
      }
      @media (max-width: 768px) {
        .sidebar {
          width: 100%;
          height: auto;
          position: relative;
        }
        .main-content {
          margin-left: 0;
        }
      }
    </style>
  </head>
  <body class="white-bg">
    <!-- Background Switcher -->
    <div class="bg-switcher">
      <label for="bg-select">Background:</label>
      <select id="bg-select" onchange="changeBackground()">
        <option value="white-bg">White</option>
        <option value="grey-bg">Grey</option>
        <option value="black-bg">Black</option>
      </select>
    </div>

    <!-- Sidebar -->
    <div class="sidebar">
      <div class="sidebar-title">REST API Guide</div>
      <a href="#what-is-rest" class="sidebar-link">What is REST?</a>
      <a href="#crud-operations" class="sidebar-link">CRUD Operations</a>
      <a href="#resources-and-entities" class="sidebar-link"
        >Resources & Entities</a
      >
      <a href="#state-and-representational" class="sidebar-link"
        >State & Transfer</a
      >
      <a href="#stateless-nature" class="sidebar-link">Stateless Nature</a>
      <a href="#rest-api-design" class="sidebar-link">REST API Design</a>
      <a href="#http-methods" class="sidebar-link">HTTP & Methods</a>
      <a href="#http-in-browser" class="sidebar-link">HTTP in Browser</a>
      <a href="#data-formats" class="sidebar-link">Data Formats</a>
      <a href="#modern-web-architecture" class="sidebar-link"
        >Web Architecture</a
      >
      <a href="#spring-annotations" class="sidebar-link">Spring Annotations</a>
      <a href="#summary" class="sidebar-link">Summary</a>
    </div>

    <!-- Main Content -->
    <div class="main-content">
      <div class="header">
        <h1 class="header-title">REST API Notes for Beginners</h1>
        <p class="header-subtitle">
          A comprehensive guide to understanding REST APIs with real-time
          examples
        </p>
      </div>

      <!-- Section 1: What is REST? -->
      <div class="section" id="what-is-rest">
        <h2 class="section-title">1. What is REST?</h2>
        <div class="content-line">
          <strong>Rewritten Original Text:</strong><br />
          REST, or Representational State Transfer, is a way to design web APIs
          that makes it easy for clients (like browsers or mobile apps) to
          interact with server data. It focuses on transferring the current
          state of resources, such as user profiles or job listings, in a simple
          and standardized format.
        </div>
        <h3 class="subsection-title">Explanation</h3>
        <div class="content-line">
          REST is an architectural style for designing networked applications,
          particularly web APIs. It stands for
          <strong>Representational State Transfer</strong>, meaning it focuses
          on transferring the state (data) of resources between a client (e.g.,
          a browser or mobile app) and a server in a standardized way. REST uses
          HTTP protocols to perform operations like creating, reading, updating,
          and deleting data.
        </div>
        <h3 class="subsection-title">Real-Time Example</h3>
        <div class="content-line">
          Imagine a job application platform like LinkedIn. When you view a job
          posting, update your profile, or delete a saved job, the app
          communicates with a server using REST to fetch or modify data.
        </div>
      </div>

      <!-- Section 2: CRUD Operations -->
      <div class="section" id="crud-operations">
        <h2 class="section-title">2. CRUD Operations</h2>
        <div class="content-line">
          <strong>Rewritten Original Text:</strong><br />
          In web applications, we primarily deal with data by performing four
          key actions: creating new data, reading existing data, updating data,
          and deleting data. These actions are collectively known as CRUD
          operations, which stand for Create, Read, Update, and Delete. For
          example, you might create a new record on the server, retrieve data to
          display, update existing information, or remove data you no longer
          need.
        </div>
        <h3 class="subsection-title">Explanation</h3>
        <div class="content-line">
          CRUD stands for <strong>Create, Read, Update, Delete</strong>,
          representing the four basic operations you perform on data in a web
          application. REST APIs are designed to handle these operations
          efficiently.
          <ul>
            <li>
              <strong>Create</strong>: Add new data (e.g., posting a new job).
            </li>
            <li>
              <strong>Read</strong>: Fetch existing data (e.g., viewing job
              details).
            </li>
            <li>
              <strong>Update</strong>: Modify existing data (e.g., editing a job
              description).
            </li>
            <li>
              <strong>Delete</strong>: Remove data (e.g., deleting a job
              posting).
            </li>
          </ul>
        </div>
        <h3 class="subsection-title">Real-Time Example</h3>
        <div class="content-line">
          In a job application system:
          <ul>
            <li>
              <strong>Create</strong>: An employer posts a new job listing.
            </li>
            <li>
              <strong>Read</strong>: A job seeker views all available jobs.
            </li>
            <li>
              <strong>Update</strong>: The employer updates the job’s salary
              details.
            </li>
            <li>
              <strong>Delete</strong>: The employer removes an outdated job
              listing.
            </li>
          </ul>
        </div>
      </div>

      <!-- Section 3: Resources and Entities -->
      <div class="section" id="resources-and-entities">
        <h2 class="section-title">3. Resources and Entities</h2>
        <div class="content-line">
          <strong>Rewritten Original Text:</strong><br />
          To work with data in REST, we treat server data as resources. When
          building an application, you identify key objects, called entities,
          that represent different parts of the system. For example, in a job
          application platform, a job posting is an entity, an employee’s
          profile could be another, an admin user is an entity, and a company’s
          employer profile is yet another. Each of these entities is considered
          a resource in REST—like a job resource, employee resource, or employer
          resource. When you want to add a new job, you’re creating a new job
          resource on the server. In REST APIs, we focus on managing these
          resources.
        </div>
        <h3 class="subsection-title">Explanation</h3>
        <div class="content-line">
          In REST, data on the server is treated as <strong>resources</strong>.
          A resource is anything you can identify and interact with, like a job
          posting, an employee profile, or a company. Each resource corresponds
          to an <strong>entity</strong> in your application, which is a distinct
          object with its own attributes (e.g., a job has a title, description,
          and salary).
        </div>
        <h3 class="subsection-title">Real-Time Example</h3>
        <div class="content-line">
          In a job application platform:
          <ul>
            <li>
              <strong>Job Resource</strong>: Represents job postings (e.g.,
              "Software Engineer at Google").
            </li>
            <li>
              <strong>Employee Resource</strong>: Represents job seekers’
              profiles (e.g., name, skills).
            </li>
            <li>
              <strong>Employer Resource</strong>: Represents companies (e.g.,
              Google’s employer profile).
            </li>
            <li>
              <strong>Admin Resource</strong>: Represents administrators who
              manage the platform.
            </li>
          </ul>
          When you say, “I want to add a new job,” you’re creating a new
          <strong>job resource</strong> on the server.
        </div>
      </div>

      <!-- Section 4: State and Representational State Transfer -->
      <div class="section" id="state-and-representational">
        <h2 class="section-title">
          4. State and Representational State Transfer
        </h2>
        <div class="content-line">
          <strong>Rewritten Original Text:</strong><br />
          Server data, like an employee’s profile, changes over time. For
          instance, an employee’s “current employer” might be empty at first,
          then change to a company like Google or Microsoft as they get hired.
          These changes update the resource’s data. At any moment, the resource
          has a specific value, called its <strong>state</strong>. For example,
          today an employee’s current employer might be Microsoft, but in a few
          months, it could be another company. Some data, like the employee’s
          name or ID, stays fixed, while other data, like their employer,
          changes often. This snapshot of data at a given time is the resource’s
          state. When a client, like a mobile app, asks for the employee’s
          details, the server sends the <strong>current state</strong> in a
          clear format, such as JSON. This formatted state is called the
          <strong>representational state</strong>, and sending it to the client
          is the <strong>transfer</strong> part of REST. So, REST involves
          transferring the representational state of a resource, whether from
          server to client or vice versa.
        </div>
        <h3 class="subsection-title">Explanation</h3>
        <div class="content-line">
          A <strong>state</strong> in REST refers to the current data of a
          resource at a specific moment. Resources are dynamic, meaning their
          data (state) can change over time. For example, an employee’s profile
          might have fixed data (e.g., name, ID) and changeable data (e.g.,
          current employer). When a client requests a resource, the server sends
          its <strong>current state</strong> in a
          <strong>representational</strong> format (like JSON). This process of
          sending or receiving the state is called <strong>transfer</strong>.
          <ul>
            <li>
              <strong>Fixed Data</strong>: Attributes like name or ID that
              rarely change.
            </li>
            <li>
              <strong>Dynamic Data</strong>: Attributes like current employer
              that change frequently.
            </li>
            <li>
              <strong>Representational State</strong>: The formatted data (e.g.,
              JSON) sent to the client.
            </li>
            <li>
              <strong>Transfer</strong>: Moving the state between client and
              server.
            </li>
          </ul>
        </div>
        <h3 class="subsection-title">Real-Time Example</h3>
        <div class="content-line">
          In a job application:
          <ul>
            <li>An employee’s profile has:</li>
            <ul>
              <li><strong>Fixed</strong>: Name = "John Doe", ID = "12345".</li>
              <li>
                <strong>Dynamic</strong>: Current Employer = "Microsoft" (now),
                "Telescope" (in 6 months).
              </li>
            </ul>
            <li>When a client (e.g., a mobile app) requests John’s profile:</li>
            <ul>
              <li>
                The server sends the <strong>current state</strong>:
                <code
                  >{ "name": "John Doe", "id": "12345", "currentEmployer":
                  "Microsoft" }</code
                >.
              </li>
              <li>
                If John switches jobs, the next request might return:
                <code
                  >{ "name": "John Doe", "id": "12345", "currentEmployer":
                  "Telescope" }</code
                >.
              </li>
            </ul>
          </ul>
          The server transfers the <strong>representational state</strong> (JSON
          data) to the client, hence
          <strong>Representational State Transfer</strong>.
        </div>
      </div>

      <!-- Section 5: Stateless Nature of REST -->
      <div class="section" id="stateless-nature">
        <h2 class="section-title">5. Stateless Nature of REST</h2>
        <div class="content-line">
          <strong>Rewritten Original Text:</strong><br />
          REST APIs are designed to be stateless, meaning each request from a
          client to the server must include all the information needed to
          process it. For example, when a client asks for data, it might need to
          provide a login token to prove it’s authorized. The server doesn’t
          remember previous requests, so even if the client makes a second
          request, it must again include all details, like who it is and why
          it’s asking for the data. This stateless approach simplifies the
          server and improves scalability.
        </div>
        <h3 class="subsection-title">Explanation</h3>
        <div class="content-line">
          REST is <strong>stateless</strong>, meaning each request from a client
          to the server must contain all the information needed to process it.
          The server doesn’t “remember” previous requests, so the client must
          include details like authentication tokens or resource IDs every time.
          This makes REST APIs scalable but requires clients to be explicit.
        </div>
        <h3 class="subsection-title">Real-Time Example</h3>
        <div class="content-line">
          In the job application:
          <ul>
            <li>
              A user logs in and requests job details. The request includes a
              token: <code>GET /jobs?token=xyz</code>.
            </li>
            <li>
              Later, the user requests the same job. The server doesn’t remember
              the user, so the request must again include the token:
              <code>GET /jobs?token=xyz</code>.
            </li>
            <li>
              If the token is missing, the server rejects the request, ensuring
              statelessness.
            </li>
          </ul>
        </div>
      </div>

      <!-- Section 6: REST API Design -->
      <div class="section" id="rest-api-design">
        <h2 class="section-title">6. REST API Design (Nouns vs Verbs)</h2>
        <div class="content-line">
          <strong>Rewritten Original Text:</strong><br />
          In REST APIs, URLs represent resources using nouns, not actions. For
          instance, instead of using URLs like <code>/viewAllJobs</code> or
          <code>/addJob</code> (which describe actions with verbs), REST uses
          nouns like <code>/jobs</code> to represent the job resource. To get
          all jobs, you’d use <code>http://localhost:8080/jobs</code>. To add a
          job or get a single job, you might use
          <code>http://localhost:8080/job</code>. If the URLs for adding and
          getting a job are the same, how do we tell them apart? The difference
          lies in the HTTP method used, like POST for adding or GET for
          retrieving.
        </div>
        <h3 class="subsection-title">Explanation</h3>
        <div class="content-line">
          REST APIs use <strong>nouns</strong> (resources) in URLs, not
          <strong>verbs</strong> (actions). Instead of <code>/addJob</code> or
          <code>/viewJobs</code>, you use <code>/jobs</code> or
          <code>/job</code> to represent the resource. The action (e.g., create,
          read) is determined by the HTTP method, not the URL.
          <ul>
            <li>
              <strong>Bad Practice</strong>: <code>/viewAllJobs</code>,
              <code>/addJob</code> (uses verbs).
            </li>
            <li>
              <strong>REST Practice</strong>: <code>/jobs</code> (noun,
              represents the resource).
            </li>
          </ul>
          If two operations (e.g., add a job, get a job) use the same URL
          (<code>/job</code>), the HTTP method (e.g., POST for add, GET for get)
          differentiates them.
        </div>
        <h3 class="subsection-title">Real-Time Example</h3>
        <div class="content-line">
          In the job application:
          <ul>
            <li>
              To get all jobs: <code>GET /jobs</code> (returns a list of jobs).
            </li>
            <li>To add a job: <code>POST /job</code> (creates a new job).</li>
            <li>
              To get one job: <code>GET /job/123</code> (returns job with ID
              123).
            </li>
          </ul>
          The URLs focus on the <strong>job</strong> resource, and the HTTP
          method defines the action.
        </div>
      </div>

      <!-- Section 7: HTTP and HTTP Methods -->
      <div class="section" id="http-methods">
        <h2 class="section-title">7. HTTP and HTTP Methods</h2>
        <div class="content-line">
          <strong>Rewritten Original Text:</strong><br />
          REST APIs rely on HTTP, which stands for Hypertext Transfer Protocol,
          the standard way we communicate on the web. HTTP offers several
          methods, but the most important ones for REST are GET, POST, PUT, and
          DELETE. In our job application example, we used GET to fetch data,
          like retrieving a list of jobs, and POST to send data to the server,
          like creating a new job posting. GET is for reading data, POST is
          mainly for creating new data (though it can sometimes update data),
          PUT is for updating existing data, and DELETE is for removing data.
          These methods match the CRUD operations: Create (POST), Read (GET),
          Update (PUT), and Delete (DELETE). For example, to add a job, you’d
          use <code>POST /job</code>, and to get a job, you’d use
          <code>GET /job</code>. The URL stays the same, but the HTTP method
          tells the server what action to perform. Both the client and server
          need to specify the method, like POST, to ensure they’re aligned.
        </div>
        <h3 class="subsection-title">Explanation</h3>
        <div class="content-line">
          HTTP (Hypertext Transfer Protocol) is the foundation of web
          communication, and REST uses HTTP methods to perform CRUD operations
          on resources. The main HTTP methods are:
          <ul>
            <li><strong>GET</strong>: Retrieve data (Read).</li>
            <li><strong>POST</strong>: Create new data (Create).</li>
            <li><strong>PUT</strong>: Update existing data (Update).</li>
            <li><strong>DELETE</strong>: Remove data (Delete).</li>
          </ul>
          These methods align with CRUD operations, and REST APIs use them to
          interact with resources. The same URL (e.g., <code>/job</code>) can
          support multiple operations based on the method.
        </div>
        <h3 class="subsection-title">Real-Time Example</h3>
        <div class="content-line">
          In the job application:
          <ul>
            <li><strong>GET /jobs</strong>: Fetch all job listings (Read).</li>
            <li>
              <strong>POST /job</strong>: Create a new job posting (Create).
            </li>
            <li>
              <strong>PUT /job/123</strong>: Update job ID 123’s details
              (Update).
            </li>
            <li>
              <strong>DELETE /job/123</strong>: Delete job ID 123 (Delete).
            </li>
          </ul>
        </div>
        <h3 class="subsection-title">
          Code Example (Spring Boot REST Controller)
        </h3>
        <pre class="code-block">
<span class="keyword-highlight">import</span> org.springframework.web.bind.annotation.<span class="class-highlight">RestController</span>;
<span class="keyword-highlight">import</span> org.springframework.web.bind.annotation.<span class="class-highlight">GetMapping</span>;
<span class="keyword-highlight">import</span> org.springframework.web.bind.annotation.<span class="class-highlight">PostMapping</span>;
<span class="keyword-highlight">import</span> org.springframework.web.bind.annotation.<span class="class-highlight">PutMapping</span>;
<span class="keyword-highlight">import</span> org.springframework.web.bind.annotation.<span class="class-highlight">DeleteMapping</span>;
<span class="keyword-highlight">import</span> org.springframework.web.bind.annotation.<span class="class-highlight">PathVariable</span>;
<span class="keyword-highlight">import</span> org.springframework.web.bind.annotation.<span class="class-highlight">RequestBody</span>;

<span class="annotation-highlight">@RestController</span>
<span class="annotation-highlight">@RequestMapping</span>(<span class="string-highlight">"/job"</span>)
<span class="keyword-highlight">public</span> <span class="keyword-highlight">class</span> <span class="class-highlight">JobController</span> {

    <span class="comment-highlight">// GET method to retrieve a job by ID</span>
    <span class="annotation-highlight">@GetMapping</span>(<span class="string-highlight">"/{id}"</span>)
    <span class="keyword-highlight">public</span> <span class="class-highlight">Job</span> getJob(<span class="annotation-highlight">@PathVariable</span> <span class="class-highlight">Long</span> id) {
        <span class="comment-highlight">// Simulate fetching job from database</span>
        <span class="keyword-highlight">return</span> <span class="keyword-highlight">new</span> <span class="class-highlight">Job</span>(id, <span class="string-highlight">"Software Engineer"</span>, <span class="string-highlight">"Google"</span>);
    }

    <span class="comment-highlight">// POST method to create a new job</span>
    <span class="annotation-highlight">@PostMapping</span>
    <span class="keyword-highlight">public</span> <span class="class-highlight">Job</span> createJob(<span class="annotation-highlight">@RequestBody</span> <span class="class-highlight">Job</span> job) {
        <span class="comment-highlight">// Simulate saving job to database</span>
        <span class="keyword-highlight">return</span> job;
    }

    <span class="comment-highlight">// PUT method to update an existing job</span>
    <span class="annotation-highlight">@PutMapping</span>(<span class="string-highlight">"/{id}"</span>)
    <span class="keyword-highlight">public</span> <span class="class-highlight">Job</span> updateJob(<span class="annotation-highlight">@PathVariable</span> <span class="class-highlight">Long</span> id, <span class="annotation-highlight">@RequestBody</span> <span class="class-highlight">Job</span> job) {
        <span class="comment-highlight">// Simulate updating job in database</span>
        job.setId(id);
        <span class="keyword-highlight">return</span> job;
    }

    <span class="comment-highlight">// DELETE method to remove a job</span>
    <span class="annotation-highlight">@DeleteMapping</span>(<span class="string-highlight">"/{id}"</span>)
    <span class="keyword-highlight">public</span> <span class="class-highlight">String</span> deleteJob(<span class="annotation-highlight">@PathVariable</span> <span class="class-highlight">Long</span> id) {
        <span class="comment-highlight">// Simulate deleting job from database</span>
        <span class="keyword-highlight">return</span> <span class="string-highlight">"Job "</span> + id + <span class="string-highlight">" deleted"</span>;
    }
}

<span class="comment-highlight">// Job class for data transfer</span>
<span class="keyword-highlight">class</span> <span class="class-highlight">Job</span> {
    <span class="keyword-highlight">private</span> <span class="class-highlight">Long</span> id;
    <span class="keyword-highlight">private</span> <span class="class-highlight">String</span> title;
    <span class="keyword-highlight">private</span> <span class="class-highlight">String</span> company;

    <span class="keyword-highlight">public</span> <span class="class-highlight">Job</span>(<span class="class-highlight">Long</span> id, <span class="class-highlight">String</span> title, <span class="class-highlight">String</span> company) {
        <span class="keyword-highlight">this</span>.id = id;
        <span class="keyword-highlight">this</span>.title = title;
        <span class="keyword-highlight">this</span>.company = company;
    }

    <span class="comment-highlight">// Getters and setters</span>
    <span class="keyword-highlight">public</span> <span class="class-highlight">Long</span> getId() { <span class="keyword-highlight">return</span> id; }
    <span class="keyword-highlight">public</span> <span class="keyword-highlight">void</span> setId(<span class="class-highlight">Long</span> id) { <span class="keyword-highlight">this</span>.id = id; }
    <span class="keyword-highlight">public</span> <span class="class-highlight">String</span> getTitle() { <span class="keyword-highlight">return</span> title; }
    <span class="keyword-highlight">public</span> <span class="keyword-highlight">void</span> setTitle(<span class="class-highlight">String</span> title) { <span class="keyword-highlight">this</span>.title = title; }
    <span class="keyword-highlight">public</span> <span class="class-highlight">String</span> getCompany() { <span class="keyword-highlight">return</span> company; }
    <span class="keyword-highlight">public</span> <span class="keyword-highlight">void</span> setCompany(<span class="class-highlight">String</span> company) { <span class="keyword-highlight">this</span>.company = company; }
}
            </pre>
        <h3 class="subsection-title">Code Explanation</h3>
        <div class="content-line">
          <ul>
            <li>
              <strong>@RestController</strong>: Marks the class as a REST
              controller that returns JSON data.
            </li>
            <li>
              <strong>@RequestMapping("/job")</strong>: Sets the base URL for
              all endpoints in this controller.
            </li>
            <li>
              <strong>@GetMapping("/{id}")</strong>: Handles GET requests to
              fetch a job by ID.
            </li>
            <li>
              <strong>@PostMapping</strong>: Handles POST requests to create a
              new job.
            </li>
            <li>
              <strong>@PutMapping("/{id}")</strong>: Handles PUT requests to
              update a job.
            </li>
            <li>
              <strong>@DeleteMapping("/{id}")</strong>: Handles DELETE requests
              to delete a job.
            </li>
            <li>
              <strong>@PathVariable</strong>: Extracts the <code>id</code> from
              the URL.
            </li>
            <li>
              <strong>@RequestBody</strong>: Converts the JSON payload into a
              <code>Job</code> object.
            </li>
            <li>
              The <code>Job</code> class represents the job resource with fields
              like <code>id</code>, <code>title</code>, and
              <code>company</code>.
            </li>
          </ul>
        </div>
      </div>

      <!-- Section 8: HTTP Methods in Browser and Testing -->
      <div class="section" id="http-in-browser">
        <h2 class="section-title">8. HTTP Methods in Browser and Testing</h2>
        <div class="content-line">
          <strong>Rewritten Original Text:</strong><br />
          You might wonder how to use HTTP methods like POST or PUT. In a
          browser, entering a URL typically triggers a GET request, like
          fetching a webpage. However, browsers don’t directly support POST,
          PUT, or DELETE requests through the address bar. To send a POST
          request, you’d usually need a web form, but what if you’re just
          testing the API? That’s where a REST client comes in. A client could
          be a frontend app, like one built with React, or a testing tool like
          Postman. Postman is a popular REST client that lets you send any HTTP
          method to test your API, and we’ll explore how to use it later.
        </div>
        <h3 class="subsection-title">Explanation</h3>
        <div class="content-line">
          Browsers primarily support <strong>GET</strong> requests (e.g., typing
          a URL like <code>http://localhost:8080/jobs</code>). For
          <strong>POST</strong>, <strong>PUT</strong>, or
          <strong>DELETE</strong>, you typically need a form or a programmatic
          client because browsers don’t natively support these methods in the
          address bar. A <strong>REST client</strong> like
          <strong>Postman</strong> allows you to test all HTTP methods by
          specifying the URL, method, headers, and body.
        </div>
        <h3 class="subsection-title">Real-Time Example</h3>
        <div class="content-line">
          In the job application:
          <ul>
            <li>
              To test <code>GET /jobs</code>, you can enter
              <code>http://localhost:8080/jobs</code> in a browser.
            </li>
            <li>
              To test <code>POST /job</code> (e.g., to create a job), you can’t
              use the browser directly. Instead, use Postman:
            </li>
            <ul>
              <li>Set method to POST.</li>
              <li>URL: <code>http://localhost:8080/job</code>.</li>
              <li>
                Body:
                <code>{"title": "Software Engineer", "company": "Google"}</code
                >.
              </li>
            </ul>
            <li>
              Postman lets you simulate a React app or mobile app making these
              requests.
            </li>
          </ul>
        </div>
      </div>

      <!-- Section 9: Data Formats -->
      <div class="section" id="data-formats">
        <h2 class="section-title">9. Data Formats (JSON and XML)</h2>
        <div class="content-line">
          <strong>Rewritten Original Text:</strong><br />
          In REST APIs, the server doesn’t send full webpages like JSP files;
          instead, it sends raw data representing the resource’s current state.
          The two most common formats for this data are JSON and XML. JSON, or
          JavaScript Object Notation, is newer, easier to read, and uses less
          space, making it the preferred choice. XML, an older format, is more
          complex. For example, JSON data looks simple and clean, while XML uses
          tags that make it bulkier. Despite its name, JSON isn’t just for
          JavaScript—it works with any programming language. Whether sending
          data from the client to the server or vice versa, JSON is typically
          used, supporting browsers, Android apps, iOS apps, and more.
        </div>
        <h3 class="subsection-title">Explanation</h3>
        <div class="content-line">
          REST APIs return data (the resource’s state) in structured formats
          like <strong>JSON</strong> (JavaScript Object Notation) or
          <strong>XML</strong> (Extensible Markup Language). JSON is preferred
          because it’s lightweight, human-readable, and widely supported across
          programming languages. XML is older, more verbose, and less commonly
          used today.
          <ul>
            <li>
              <strong>JSON</strong>: <code>{ "key": "value" }</code> (simple
              key-value pairs).
            </li>
            <li>
              <strong>XML</strong>:
              <code>&lt;key&gt;value&lt;/key&gt;</code> (uses tags, more
              complex).
            </li>
          </ul>
        </div>
        <h3 class="subsection-title">Real-Time Example</h3>
        <div class="content-line">
          In the job application:
          <ul>
            <li><strong>JSON Response</strong> for a job:</li>
            <pre class="code-block">
{
  <span class="json-key">"id"</span>: <span class="json-number">123</span>,
  <span class="json-key">"title"</span>: <span class="json-string">"Software Engineer"</span>,
  <span class="json-key">"company"</span>: <span class="json-string">"Google"</span>
}
                    </pre>
            <li><strong>XML Response</strong> (equivalent):</li>
            <pre class="code-block">
<span class="xml-element">&lt;job&gt;</span>
  <span class="xml-element">&lt;id&gt;</span><span class="xml-value">123</span><span class="xml-element">&lt;/id&gt;</span>
  <span class="xml-element">&lt;title&gt;</span><span class="xml-value">Software Engineer</span><span class="xml-element">&lt;/title&gt;</span>
  <span class="xml-element">&lt;company&gt;</span><span class="xml-value">Google</span><span class="xml-element">&lt;/company&gt;</span>
<span class="xml-element">&lt;/job&gt;</span>
                    </pre>
            <li>
              The JSON version is shorter and easier to read, so the server uses
              JSON to send job data to a mobile app or browser.
            </li>
          </ul>
        </div>
      </div>

      <!-- Section 10: Modern Web Application Architecture -->
      <div class="section" id="modern-web-architecture">
        <h2 class="section-title">10. Modern Web Application Architecture</h2>
        <div class="content-line">
          <strong>Rewritten Original Text:</strong><br />
          In the past, web applications combined the frontend (user interface)
          and backend (data processing) into a single system. Users accessed
          these applications through browsers, receiving complete webpages. Now,
          mobile apps, like Facebook, LinkedIn, or those for checking cricket
          scores, offer the same functionality as browsers. Browsers expect HTML
          pages, while mobile apps need raw data, such as JSON. Instead of
          maintaining two separate servers—one for browsers delivering HTML and
          another for mobile apps delivering data—we can build a single server
          that returns only data, not webpages. However, browsers receiving JSON
          data alone won’t display a proper user interface. To address this, we
          create a separate frontend using technologies like React or Angular,
          which fetches JSON data from the server and builds the UI. The backend
          server then handles only JSON or sometimes XML data, as these are the
          two most common formats. This approach, enabled by REST APIs, allows a
          single backend to serve browsers, mobile apps, and other systems. To
          verify the data being sent or received, we use tools like Postman to
          interact with the REST API.
        </div>
        <h3 class="subsection-title">Explanation</h3>
        <div class="content-line">
          In the past, web applications had a
          <strong>monolithic</strong> architecture where the server handled both
          the backend (data) and frontend (HTML pages). Browsers expected full
          HTML pages (e.g., JSP files). Today, with mobile apps and diverse
          clients (browsers, iOS, Android), servers focus on returning
          <strong>data</strong> (JSON or XML) instead of HTML. This is achieved
          using <strong>REST APIs</strong>.
          <ul>
            <li>
              <strong>Old Architecture</strong>: Server returns HTML for
              browsers.
            </li>
            <li>
              <strong>New Architecture</strong>:
              <ul>
                <li>
                  <strong>Backend</strong>: A REST API server that returns
                  JSON/XML data.
                </li>
                <li>
                  <strong>Frontend</strong>: A separate UI built with React,
                  Angular, or native mobile apps that consumes the API.
                </li>
              </ul>
            </li>
            <li>
              <strong>Advantage</strong>: One backend serves multiple clients
              (browsers, mobile apps, other servers) with consistent data.
            </li>
          </ul>
        </div>
        <h3 class="subsection-title">Real-Time Example</h3>
        <div class="content-line">
          <ul>
            <li>
              <strong>Old Way</strong>: A job application website returns full
              HTML pages for job listings, viewable only in browsers.
            </li>
            <li>
              <strong>New Way</strong>:
              <ul>
                <li>
                  Backend REST API returns JSON: <code>GET /jobs</code> →
                  <code>[{"id": 123, "title": "Software Engineer"}]</code>.
                </li>
                <li>
                  Frontend (React app) fetches this JSON and displays it as a
                  nice UI.
                </li>
                <li>
                  Mobile app (iOS/Android) fetches the same JSON to show jobs in
                  the app.
                </li>
                <li>
                  Example apps: <strong>Facebook</strong>,
                  <strong>LinkedIn</strong>, or a
                  <strong>cricket score app</strong>—all use REST APIs to serve
                  data to browsers and mobile apps.
                </li>
              </ul>
            </li>
          </ul>
        </div>
      </div>

      <!-- Section 11: Spring Annotations and REST Controller -->
      <div class="section" id="spring-annotations">
        <h2 class="section-title">
          11. Spring Annotations and REST Controller
        </h2>
        <div class="content-line">
          <strong>Rewritten Original Text:</strong><br />
          Spring Boot provides annotations to simplify REST API development.
          These include <code>@RequestMapping</code> to define URL paths,
          <code>@GetMapping</code> for GET requests,
          <code>@PostMapping</code> for POST requests,
          <code>@PutMapping</code> for PUT requests, and
          <code>@DeleteMapping</code> for DELETE requests. The
          <code>@Controller</code> annotation marks a class for handling web
          requests, while <code>@RestController</code> is used specifically for
          REST APIs to return data like JSON.
          <code>@RequestParam</code> captures query parameters,
          <code>@ModelAttribute</code> binds form data to objects, and
          <code>@RequestBody</code> converts JSON data into Java objects.
          <code>@PathVariable</code> extracts values from URLs, and
          <code>@CrossOrigin</code> allows a frontend, like a React app, to
          connect to the API. A DTO (Data Transfer Object) is a pattern for
          structuring data sent between client and server.
        </div>
        <h3 class="subsection-title">Explanation</h3>
        <div class="content-line">
          In Spring Boot, <strong>annotations</strong> are used to define REST
          APIs. They simplify how you map HTTP requests to Java methods and
          handle data. Below is a detailed explanation of each annotation, with
          examples from the job application context.
        </div>
        <h3 class="subsection-title">Annotations with Explanations</h3>
        <div class="content-line">
          <ol>
            <li>
              <strong>@RestController</strong>:
              <ul>
                <li>
                  <strong>Explanation</strong>: Marks a class as a REST
                  controller. It handles HTTP requests and returns data (e.g.,
                  JSON) instead of views (e.g., HTML). Combines
                  <code>@Controller</code> and <code>@ResponseBody</code>.
                </li>
                <li>
                  <strong>Real-Time Example</strong>: In the job application,
                  the <code>JobController</code> class uses
                  <code>@RestController</code> to handle job-related requests
                  and return JSON data.
                </li>
                <li>
                  <strong>Additional Points</strong>:
                  <ul>
                    <li>
                      Automatically serializes return objects to JSON/XML based
                      on client request headers.
                    </li>
                    <li>
                      Simplifies API development by eliminating the need for
                      <code>@ResponseBody</code> on each method.
                    </li>
                    <li>
                      Commonly used with Spring’s dependency injection to
                      integrate services or repositories.
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
            <li>
              <strong>@RequestMapping</strong>:
              <ul>
                <li>
                  <strong>Explanation</strong>: Maps HTTP requests to a specific
                  method or class. It can specify the URL path and HTTP method
                  (e.g., GET, POST).
                </li>
                <li>
                  <strong>Real-Time Example</strong>:
                  <code>@RequestMapping("/job")</code> on a controller sets the
                  base URL for all job-related endpoints.
                </li>
                <li>
                  <strong>Additional Points</strong>:
                  <ul>
                    <li>
                      Supports multiple HTTP methods (e.g.,
                      <code
                        >@RequestMapping(method = {RequestMethod.GET,
                        RequestMethod.POST})</code
                      >).
                    </li>
                    <li>
                      Can include path patterns, like <code>/job/*</code>, for
                      flexible routing.
                    </li>
                    <li>
                      Allows specifying headers or media types for fine-grained
                      request matching.
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
            <li>
              <strong>@GetMapping</strong>:
              <ul>
                <li>
                  <strong>Explanation</strong>: A shortcut for
                  <code>@RequestMapping(method = RequestMethod.GET)</code>.
                  Handles GET requests to retrieve data.
                </li>
                <li>
                  <strong>Real-Time Example</strong>:
                  <code>@GetMapping("/{id}")</code> fetches a job by ID, like
                  <code>GET /job/123</code>.
                </li>
              </ul>
            </li>
            <li>
              <strong>@PostMapping</strong>:
              <ul>
                <li>
                  <strong>Explanation</strong>: A shortcut for
                  <code>@RequestMapping(method = RequestMethod.POST)</code>.
                  Handles POST requests to create data.
                </li>
                <li>
                  <strong>Real-Time Example</strong>:
                  <code>@PostMapping</code> creates a new job with
                  <code>POST /job</code>.
                </li>
              </ul>
            </li>
            <li>
              <strong>@PutMapping</strong>:
              <ul>
                <li>
                  <strong>Explanation</strong>: A shortcut for
                  <code>@RequestMapping(method = RequestMethod.PUT)</code>.
                  Handles PUT requests to update data.
                </li>
                <li>
                  <strong>Real-Time Example</strong>:
                  <code>@PutMapping("/{id}")</code> updates a job, like
                  <code>PUT /job/123</code>.
                </li>
              </ul>
            </li>
            <li>
              <strong>@DeleteMapping</strong>:
              <ul>
                <li>
                  <strong>Explanation</strong>: A shortcut for
                  <code>@RequestMapping(method = RequestMethod.DELETE)</code>.
                  Handles DELETE requests to remove data.
                </li>
                <li>
                  <strong>Real-Time Example</strong>:
                  <code>@DeleteMapping("/{id}")</code> deletes a job, like
                  <code>DELETE /job/123</code>.
                </li>
              </ul>
            </li>
            <li>
              <strong>@Controller</strong>:
              <ul>
                <li>
                  <strong>Explanation</strong>: Marks a class as a web
                  controller for handling HTTP requests. Unlike
                  <code>@RestController</code>, it typically returns views
                  (e.g., HTML) unless combined with <code>@ResponseBody</code>.
                </li>
                <li>
                  <strong>Real-Time Example</strong>: Rarely used in REST APIs;
                  <code>@RestController</code> is preferred for the job
                  application.
                </li>
              </ul>
            </li>
            <li>
              <strong>@RequestParam</strong>:
              <ul>
                <li>
                  <strong>Explanation</strong>: Extracts query parameters from
                  the URL (e.g., <code>?key=value</code>). Useful for filtering
                  or optional inputs.
                </li>
                <li>
                  <strong>Real-Time Example</strong>:
                  <code>GET /jobs?company=Google</code> uses
                  <code>@RequestParam String company</code> to filter jobs by
                  company.
                </li>
                <li>
                  <strong>Additional Points</strong>:
                  <ul>
                    <li>
                      Supports default values (e.g.,
                      <code
                        >@RequestParam(defaultValue = "all") String filter</code
                      >).
                    </li>
                    <li>
                      Can be marked as optional with
                      <code>required = false</code>.
                    </li>
                    <li>
                      Useful for pagination (e.g.,
                      <code>?page=1&size=10</code>).
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
            <li>
              <strong>@ModelAttribute</strong>:
              <ul>
                <li>
                  <strong>Explanation</strong>: Binds form data or query
                  parameters to a Java object. Common in traditional web apps
                  but less used in REST APIs.
                </li>
                <li>
                  <strong>Real-Time Example</strong>: In a non-REST job form,
                  <code>@ModelAttribute</code> could bind form fields to a
                  <code>Job</code> object (not typical for JSON-based REST).
                </li>
              </ul>
            </li>
            <li>
              <strong>DTO (Data Transfer Object)</strong>:
              <ul>
                <li>
                  <strong>Explanation</strong>: A design pattern (not an
                  annotation) for objects that carry data between client and
                  server. DTOs simplify data exchange by including only
                  necessary fields.
                </li>
                <li>
                  <strong>Real-Time Example</strong>: A
                  <code>JobDTO</code> might include <code>title</code> and
                  <code>company</code> but exclude internal fields like
                  <code>createdDate</code>.
                </li>
              </ul>
            </li>
            <li>
              <strong>@CrossOrigin</strong>:
              <ul>
                <li>
                  <strong>Explanation</strong>: Enables
                  <strong>CORS</strong> (Cross-Origin Resource Sharing),
                  allowing a frontend (e.g., React) hosted on a different domain
                  to access the API.
                </li>
                <li>
                  <strong>Real-Time Example</strong>: If the React frontend is
                  at <code>http://localhost:3000</code> and the API is at
                  <code>http://localhost:8080</code>,
                  <code>@CrossOrigin</code> allows the frontend to make
                  requests.
                </li>
                <li>
                  <strong>Additional Points</strong>:
                  <ul>
                    <li>
                      Can specify allowed origins (e.g.,
                      <code>@CrossOrigin(origins = "http://example.com")</code
                      >).
                    </li>
                    <li>
                      Supports configuration for allowed methods, headers, and
                      credentials.
                    </li>
                    <li>
                      Essential for modern web apps with separate frontend and
                      backend domains.
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
            <li>
              <strong>@PathVariable</strong>:
              <ul>
                <li>
                  <strong>Explanation</strong>: Extracts variables from the URL
                  path (e.g., <code>/job/{id}</code> binds <code>id</code> to a
                  method parameter).
                </li>
                <li>
                  <strong>Real-Time Example</strong>: In
                  <code>GET /job/123</code>,
                  <code>@PathVariable Long id</code> captures <code>123</code>.
                </li>
                <li>
                  <strong>Additional Points</strong>:
                  <ul>
                    <li>
                      Supports regex patterns for validation (e.g.,
                      <code>{id:\\d+}</code> ensures <code>id</code> is
                      numeric).
                    </li>
                    <li>
                      Can handle multiple variables in a single URL (e.g.,
                      <code>/job/{id}/department/{deptId}</code>).
                    </li>
                    <li>
                      Optional with <code>required = false</code>, though less
                      common.
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
            <li>
              <strong>@RequestBody</strong>:
              <ul>
                <li>
                  <strong>Explanation</strong>: Converts the HTTP request body
                  (e.g., JSON) into a Java object.
                </li>
                <li>
                  <strong>Real-Time Example</strong>: In
                  <code>POST /job</code> with body
                  <code>{"title": "Software Engineer"}</code>,
                  <code>@RequestBody Job job</code> creates a
                  <code>Job</code> object.
                </li>
              </ul>
            </li>
          </ol>
        </div>
        <h3 class="subsection-title">
          Code Example (Extended Spring Boot REST Controller)
        </h3>
        <pre class="code-block">
<span class="keyword-highlight">import</span> org.springframework.web.bind.annotation.<span class="class-highlight">RestController</span>;
<span class="keyword-highlight">import</span> org.springframework.web.bind.annotation.<span class="class-highlight">RequestMapping</span>;
<span class="keyword-highlight">import</span> org.springframework.web.bind.annotation.<span class="class-highlight">GetMapping</span>;
<span class="keyword-highlight">import</span> org.springframework.web.bind.annotation.<span class="class-highlight">PostMapping</span>;
<span class="keyword-highlight">import</span> org.springframework.web.bind.annotation.<span class="class-highlight">PutMapping</span>;
<span class="keyword-highlight">import</span> org.springframework.web.bind.annotation.<span class="class-highlight">DeleteMapping</span>;
<span class="keyword-highlight">import</span> org.springframework.web.bind.annotation.<span class="class-highlight">RequestParam</span>;
<span class="keyword-highlight">import</span> org.springframework.web.bind.annotation.<span class="class-highlight">PathVariable</span>;
<span class="keyword-highlight">import</span> org.springframework.web.bind.annotation.<span class="class-highlight">RequestBody</span>;
<span class="keyword-highlight">import</span> org.springframework.web.bind.annotation.<span class="class-highlight">ModelAttribute</span>;
<span class="keyword-highlight">import</span> org.springframework.web.bind.annotation.<span class="class-highlight">CrossOrigin</span>;
<span class="keyword-highlight">import</span> java.util.<span class="class-highlight">List</span>;
<span class="keyword-highlight">import</span> java.util.<span class="class-highlight">ArrayList</span>;

<span class="annotation-highlight">@RestController</span>
<span class="annotation-highlight">@RequestMapping</span>(<span class="string-highlight">"/job"</span>)
<span class="annotation-highlight">@CrossOrigin</span>(<span class="string-highlight">origins = "http://localhost:3000"</span>) <span class="comment-highlight">// Allow React frontend to access API</span>
<span class="keyword-highlight">public</span> <span class="keyword-highlight">class</span> <span class="class-highlight">JobController</span> {

    <span class="comment-highlight">// GET all jobs with optional company filter</span>
    <span class="annotation-highlight">@GetMapping</span>
    <span class="keyword-highlight">public</span> <span class="class-highlight">List</span>&lt;<span class="class-highlight">JobDTO</span>&gt; getAllJobs(<span class="annotation-highlight">@RequestParam</span>(<span class="string-highlight">required = false</span>) <span class="class-highlight">String</span> company) {
        <span class="comment-highlight">// Simulate fetching jobs from database</span>
        <span class="class-highlight">List</span>&lt;<span class="class-highlight">JobDTO</span>&gt; jobs = <span class="keyword-highlight">new</span> <span class="class-highlight">ArrayList</span>&lt;&gt;();
        <span class="keyword-highlight">if</span> (company != <span class="keyword-highlight">null</span>) {
            jobs.add(<span class="keyword-highlight">new</span> <span class="class-highlight">JobDTO</span>(<span class="string-highlight">"Software Engineer"</span>, company));
        } <span class="keyword-highlight">else</span> {
            jobs.add(<span class="keyword-highlight">new</span> <span class="class-highlight">JobDTO</span>(<span class="string-highlight">"Software Engineer"</span>, <span class="string-highlight">"Google"</span>));
            jobs.add(<span class="keyword-highlight">new</span> <span class="class-highlight">JobDTO</span>(<span class="string-highlight">"Data Scientist"</span>, <span class="string-highlight">"Microsoft"</span>));
        }
        <span class="keyword-highlight">return</span> jobs;
    }

    <span class="comment-highlight">// GET a job by ID</span>
    <span class="annotation-highlight">@GetMapping</span>(<span class="string-highlight">"/{id}"</span>)
    <span class="keyword-highlight">public</span> <span class="class-highlight">JobDTO</span> getJob(<span class="annotation-highlight">@PathVariable</span> <span class="class-highlight">Long</span> id) {
        <span class="comment-highlight">// Simulate fetching job from database</span>
        <span class="keyword-highlight">return</span> <span class="keyword-highlight">new</span> <span class="class-highlight">JobDTO</span>(<span class="string-highlight">"Software Engineer"</span>, <span class="string-highlight">"Google"</span>);
    }

    <span class="comment-highlight">// POST to create a new job</span>
    <span class="annotation-highlight">@PostMapping</span>
    <span class="keyword-highlight">public</span> <span class="class-highlight">JobDTO</span> createJob(<span class="annotation-highlight">@RequestBody</span> <span class="class-highlight">JobDTO</span> job) {
        <span class="comment-highlight">// Simulate saving job to database</span>
        <span class="keyword-highlight">return</span> job;
    }

    <span class="comment-highlight">// PUT to update a job</span>
    <span class="annotation-highlight">@PutMapping</span>(<span class="string-highlight">"/{id}"</span>)
    <span class="keyword-highlight">public</span> <span class="class-highlight">JobDTO</span> updateJob(<span class="annotation-highlight">@PathVariable</span> <span class="class-highlight">Long</span> id, <span class="annotation-highlight">@RequestBody</span> <span class="class-highlight">JobDTO</span> job) {
        <span class="comment-highlight">// Simulate updating job in database</span>
        <span class="keyword-highlight">return</span> job;
    }

    <span class="comment-highlight">// DELETE a job</span>
    <span class="annotation-highlight">@DeleteMapping</span>(<span class="string-highlight">"/{id}"</span>)
    <span class="keyword-highlight">public</span> <span class="class-highlight">String</span> deleteJob(<span class="annotation-highlight">@PathVariable</span> <span class="class-highlight">Long</span> id) {
        <span class="comment-highlight">// Simulate deleting job from database</span>
        <span class="keyword-highlight">return</span> <span class="string-highlight">"Job "</span> + id + <span class="string-highlight">" deleted"</span>;
    }

    <span class="comment-highlight">// Example of ModelAttribute (less common in REST)</span>
    <span class="annotation-highlight">@PostMapping</span>(<span class="string-highlight">"/form"</span>)
    <span class="keyword-highlight">public</span> <span class="class-highlight">JobDTO</span> createJobFromForm(<span class="annotation-highlight">@ModelAttribute</span> <span class="class-highlight">JobDTO</span> job) {
        <span class="comment-highlight">// Simulate processing form data (not typical for REST)</span>
        <span class="keyword-highlight">return</span> job;
    }
}

<span class="comment-highlight">// DTO for transferring job data</span>
<span class="keyword-highlight">class</span> <span class="class-highlight">JobDTO</span> {
    <span class="keyword-highlight">private</span> <span class="class-highlight">String</span> title;
    <span class="keyword-highlight">private</span> <span class="class-highlight">String</span> company;

    <span class="keyword-highlight">public</span> <span class="class-highlight">JobDTO</span>(<span class="class-highlight">String</span> title, <span class="class-highlight">String</span> company) {
        <span class="keyword-highlight">this</span>.title = title;
        <span class="keyword-highlight">this</span>.company = company;
    }

    <span class="comment-highlight">// Getters and setters</span>
    <span class="keyword-highlight">public</span> <span class="class-highlight">String</span> getTitle() { <span class="keyword-highlight">return</span> title; }
    <span class="keyword-highlight">public</span> <span class="keyword-highlight">void</span> setTitle(<span class="class-highlight">String</span> title) { <span class="keyword-highlight">this</span>.title = title; }
    <span class="keyword-highlight">public</span> <span class="class-highlight">String</span> getCompany() { <span class="keyword-highlight">return</span> company; }
    <span class="keyword-highlight">public</span> <span class="keyword-highlight">void</span> setCompany(<span class="class-highlight">String</span> company) { <span class="keyword-highlight">this</span>.company = company; }
}
            </pre>
        <h3 class="subsection-title">Code Explanation</h3>
        <div class="content-line">
          <ul>
            <li>
              <strong>@RestController</strong>: Marks the class as a REST API
              controller returning JSON.
            </li>
            <li>
              <strong>@RequestMapping("/job")</strong>: Sets
              <code>/job</code> as the base URL for all endpoints.
            </li>
            <li>
              <strong>@CrossOrigin</strong>: Allows the React frontend at
              <code>http://localhost:3000</code> to call the API.
            </li>
            <li>
              <strong>@GetMapping</strong>: Handles <code>GET /job</code> (all
              jobs) and <code>GET /job/{id}</code> (single job).
            </li>
            <li>
              <strong>@PostMapping</strong>: Handles <code>POST /job</code> to
              create a job.
            </li>
            <li>
              <strong>@PutMapping</strong>: Handles
              <code>PUT /job/{id}</code> to update a job.
            </li>
            <li>
              <strong>@DeleteMapping</strong>: Handles
              <code>DELETE /job/{id}</code> to delete a job.
            </li>
            <li>
              <strong>@RequestParam</strong>: Captures
              <code>company</code> query parameter in
              <code>GET /jobs?company=Google</code>.
            </li>
            <li>
              <strong>@PathVariable</strong>: Captures <code>id</code> from the
              URL in <code>GET /job/123</code>.
            </li>
            <li>
              <strong>@RequestBody</strong>: Converts JSON body to
              <code>JobDTO</code> in POST/PUT requests.
            </li>
            <li>
              <strong>@ModelAttribute</strong>: Shows form binding (rare in
              REST, included for completeness).
            </li>
            <li>
              <strong>JobDTO</strong>: A DTO with <code>title</code> and
              <code>company</code>, excluding unnecessary fields.
            </li>
          </ul>
        </div>
      </div>

      <!-- Section 12: Summary -->
      <div class="section" id="summary">
        <h2 class="section-title">Summary</h2>
        <div class="content-line">
          These notes cover the complete journey of understanding REST APIs,
          from basic concepts (REST, CRUD, resources) to practical
          implementation (HTTP methods, Spring annotations). The
          <strong>job application</strong> example ties everything together,
          showing how a real system uses REST to manage jobs, employees, and
          employers. The code examples demonstrate how to build a REST API in
          Spring Boot, with annotations making it easy to map requests to
          methods.
        </div>
        <h3 class="subsection-title">Key Takeaways</h3>
        <div class="content-line">
          <ul>
            <li>
              REST is about transferring resource states (data) using HTTP.
            </li>
            <li>Resources (e.g., jobs) are identified by nouns in URLs.</li>
            <li>HTTP methods (GET, POST, PUT, DELETE) define actions.</li>
            <li>JSON is the preferred data format for modern APIs.</li>
            <li>Spring annotations simplify REST API development.</li>
            <li>
              Tools like Postman help test APIs beyond browser limitations.
            </li>
          </ul>
        </div>
      </div>
    </div>

    <!-- JavaScript for Background Switcher -->
    <script>
      function changeBackground() {
        const select = document.getElementById("bg-select");
        const body = document.body;
        body.className = select.value;
      }
    </script>
  </body>
</html>
