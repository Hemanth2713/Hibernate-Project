<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Spring AOP Notes</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 20px;
        background-color: #f1f1f1;
        line-height: 1.6;
        transition: background-color 0.3s, color 0.3s;
      }
      .white-bg {
        background-color: #ffffff;
        color: #333;
      }
      .grey-bg {
        background-color: #e0e0e0;
        color: #333;
      }
      .black-bg {
        background-color: #1a1a1a;
        color: #ffffff;
      }
      .bg-switcher {
        position: fixed;
        top: 10px;
        right: 10px;
        z-index: 1000;
        font-size: 16px;
      }
      .bg-switcher label {
        margin-right: 10px;
        color: inherit;
      }
      .bg-switcher select {
        padding: 5px;
        border-radius: 5px;
        background-color: #04aa6d;
        color: white;
        border: none;
        cursor: pointer;
      }
      .bg-switcher select:focus {
        outline: 2px solid #059862;
      }
      .sidebar {
        width: 250px;
        background-color: #04aa6d;
        position: fixed;
        top: 0;
        left: 0;
        height: 100%;
        padding-top: 20px;
        color: white;
        overflow-y: auto;
      }
      .sidebar-title {
        font-size: 24px;
        text-align: center;
        margin-bottom: 30px;
      }
      .sidebar-link {
        display: block;
        padding: 12px 20px;
        color: white;
        text-decoration: none;
        font-size: 18px;
        transition: background-color 0.3s;
      }
      .sidebar-link:hover {
        background-color: #059862;
      }
      .sidebar-link:focus {
        outline: 2px solid white;
      }
      .main-content {
        margin-left: 270px;
        padding: 30px;
      }
      .header {
        background-color: #282a35;
        color: white;
        padding: 20px;
        text-align: center;
        border-radius: 8px;
        margin-bottom: 20px;
      }
      .header-title {
        font-size: 36px;
        margin: 0;
      }
      .header-subtitle {
        font-size: 18px;
        margin-top: 10px;
      }
      .section {
        margin: 20px 0;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      }
      .white-bg .section {
        background-color: #f9f9f9;
      }
      .grey-bg .section {
        background-color: #d0d0d0;
      }
      .black-bg .section {
        background-color: #2a2a2a;
      }
      .section-title {
        font-size: 28px;
        color: #04aa6d;
        margin-bottom: 15px;
      }
      .subsection-title {
        font-size: 22px;
        margin: 15px 0 10px;
        color: inherit;
      }
      table {
        width: 100%;
        border-collapse: collapse;
        margin-bottom: 20px;
        background-color: #ffffff;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        overflow-x: auto;
      }
      th,
      td {
        padding: 12px 15px;
        text-align: left;
        border-bottom: 1px solid #ddd;
      }
      th {
        background-color: #04aa6d;
        color: white;
        font-weight: bold;
      }
      td {
        background-color: #000000;
        color: #ffffff;
      }
      tr:nth-child(even) {
        background-color: #f9f9f9;
      }
      tr:hover {
        background-color: #f1f1f1;
      }
      .content-line {
        font-size: 16px;
        margin: 8px 0;
        padding: 10px;
        border-left: 4px solid #04aa6d;
      }
      .content-line.black-highlight {
        border-left: 4px solid #000000;
      }
      .white-bg .content-line {
        background-color: #f0f0f0;
      }
      .grey-bg .content-line {
        background-color: #c0c0c0;
      }
      .black-bg .content-line {
        background-color: #333333;
      }
      .code-block {
        padding: 15px;
        border-radius: 5px;
        font-family: "Courier New", Courier, monospace;
        font-size: 16px;
        overflow-x: auto;
        margin: 10px 0;
        background-color: #282a35;
        color: white;
      }
      .code-block::-webkit-scrollbar {
        height: 8px;
      }
      .code-block::-webkit-scrollbar-thumb {
        background-color: #04aa6d;
        border-radius: 4px;
      }
      .code-block::-webkit-scrollbar-track {
        background-color: #f1f1f1;
      }
      /* Syntax highlighting styles */
      .keyword-highlight {
        color: #ffa500;
        font-size: 16px;
      } /* Orange for keywords */
      .string-highlight {
        color: #00ff00;
      } /* Green for strings */
      .comment-highlight {
        color: #808080;
      } /* Grey for comments */
      .class-highlight {
        color: #00ced1;
      } /* Cyan for class names */
      .annotation-highlight {
        color: #c71585;
      } /* Purple for annotations */
      /* JSON syntax highlighting */
      .code-block .json-key {
        color: #f8c555;
      } /* yellow-orange */
      .code-block .json-string {
        color: #9cdcfe;
      } /* light blue */
      .code-block .json-number {
        color: #b5cea8;
      } /* greenish */
      .code-block .json-boolean {
        color: #c586c0;
      } /* purple */
      .code-block .json-null {
        color: #d16969;
      } /* reddish-pink */
      /* XML syntax highlighting for pom.xml */
      .code-block .xml-element {
        color: #c586c0;
      } /* purple */
      .code-block .xml-attribute {
        color: #f8c555;
      } /* yellow-orange */
      .code-block .xml-value {
        color: #9cdcfe;
      } /* light blue */
      .code-block .xml-comment {
        color: #6a9955;
        font-style: italic;
      } /* greenish */
      /* Properties file syntax highlighting for application.properties */
      .code-block .prop-key {
        color: #f8c555;
      } /* yellow-orange, matching json-key */
      .code-block .prop-value {
        color: #9cdcfe;
      } /* light blue, matching json-string */
      .code-block .prop-comment {
        color: #6a9955;
        font-style: italic;
      } /* greenish, matching xml-comment */
      .highlight {
        color: #ff4500;
        font-weight: bold;
      }
      strong {
        font-weight: bold;
      }
      .code-heading {
        color: #000000;
        font-weight: bold;
        font-size: 16px;
      }
      a {
        color: #04aa6d;
        text-decoration: none;
      }
      a:hover {
        text-decoration: underline;
      }
      ul,
      ol {
        margin: 10px 0;
        padding-left: 20px;
      }
      li {
        margin: 5px 0;
      }
      @media (max-width: 768px) {
        .sidebar {
          width: 100%;
          height: auto;
          position: relative;
        }
        .main-content {
          margin-left: 0;
        }
      }
    </style>
  </head>
  <body class="white-bg">
    <div class="bg-switcher">
      <label for="bg-select">Background Color:</label>
      <select id="bg-select" onchange="changeBackground()">
        <option value="white-bg">White</option>
        <option value="grey-bg">Grey</option>
        <option value="black-bg">Black</option>
      </select>
    </div>

    <div class="sidebar">
      <div class="sidebar-title">Spring AOP Notes</div>
      <a href="#introduction" class="sidebar-link">Introduction</a>
      <a href="#why-aop" class="sidebar-link">Why Use AOP?</a>
      <a href="#how-aop-works" class="sidebar-link">How AOP Works</a>
      <a href="#real-world-analogy" class="sidebar-link">Real-World Analogy</a>
      <a href="#benefits" class="sidebar-link">Benefits of AOP</a>
      <a href="#key-concepts" class="sidebar-link">Key AOP Concepts</a>
      <a href="#practical-implementation" class="sidebar-link"
        >Practical Implementation</a
      >
      <a href="#additional-explanations" class="sidebar-link"
        >Additional Explanations</a
      >
      <a href="#benefits-revisited" class="sidebar-link">Benefits Revisited</a>
      <a href="#common-use-cases" class="sidebar-link">Common Use Cases</a>
      <a href="#tips-for-beginners" class="sidebar-link">Tips for Beginners</a>
      <a href="#conclusion" class="sidebar-link">Conclusion</a>
    </div>

    <div class="main-content">
      <div class="header">
        <h1 class="header-title">Spring AOP Notes</h1>
        <p class="header-subtitle">
          A Comprehensive Guide to Aspect-Oriented Programming in Spring
        </p>
      </div>

      <div class="section" id="introduction">
        <h2 class="section-title">Introduction to Spring AOP</h2>
        <p class="content-line">
          Spring AOP (Aspect-Oriented Programming) enables developers to handle
          cross-cutting concerns—functionalities like logging, security,
          exception handling, and input validation that are essential but not
          part of the core business logic.
        </p>
        <p class="content-line">
          Unlike OOP, which organizes code around objects and classes, AOP
          focuses on modularizing these concerns into aspects that can be
          applied across multiple classes without altering their code.
        </p>
        <p class="content-line">
          This separation keeps the business logic clean, enhances readability,
          and simplifies maintenance.
        </p>
      </div>

      <div class="section" id="why-aop">
        <h2 class="section-title">Why Use AOP?</h2>
        <p class="content-line">
          In a large application with thousands of lines of code, the primary
          goal is to implement business logic—the functionality that meets
          client requirements, such as saving or retrieving data in a job
          management system.
        </p>
        <p class="content-line">
          However, additional tasks are often required:
        </p>
        <ul>
          <li class="content-line">
            Logging: Tracking method calls to debug issues.
          </li>
          <li class="content-line">
            Security: Ensuring only authorized users access certain methods.
          </li>
          <li class="content-line">
            Performance Monitoring: Measuring how long methods take to execute.
          </li>
          <li class="content-line">
            Input Validation: Checking data integrity before processing.
          </li>
          <li class="content-line">
            Exception Handling: Managing errors gracefully.
          </li>
        </ul>
        <p class="content-line">
          If these tasks are embedded in the business logic, the code becomes
          cluttered.
        </p>
        <p class="content-line">
          For example, a saveJob method might include logging statements, input
          checks, and try-catch blocks, making it hard to identify the actual
          business logic.
        </p>
        <p class="content-line">
          This also complicates code reviews, testing, and maintenance, as
          developers must sift through auxiliary code to understand the core
          functionality.
        </p>
        <p class="content-line">
          Spring AOP addresses this by isolating cross-cutting concerns into
          aspects, which are executed automatically at specific points in the
          program, leaving the business logic uncluttered.
        </p>
      </div>

      <div class="section" id="how-aop-works">
        <h2 class="section-title">How AOP Works</h2>
        <p class="content-line">
          AOP introduces a mechanism to intercept method calls and apply
          additional behavior (e.g., logging) before, after, or around them.
        </p>
        <p class="content-line">This is achieved through:</p>
        <ul>
          <li class="content-line">
            Aspects: Classes that define the cross-cutting concern logic.
          </li>
          <li class="content-line">
            Pointcuts: Expressions that specify where to apply the logic.
          </li>
          <li class="content-line">
            Advice: The actions to perform at those points.
          </li>
        </ul>
        <p class="content-line">
          Spring AOP uses proxies (wrapper objects) to intercept calls to the
          target object and execute the aspect’s logic.
        </p>
        <p class="content-line">
          This process, called weaving, happens at runtime in Spring AOP,
          meaning the original code remains unchanged, and the aspect’s behavior
          is dynamically applied.
        </p>
      </div>

      <div class="section" id="real-world-analogy">
        <h2 class="section-title">Real-World Analogy</h2>
        <p class="content-line">Think of an application as a movie:</p>
        <ul>
          <li class="content-line">
            Business Logic: The main storyline (e.g., the hero’s quest).
          </li>
          <li class="content-line">
            Cross-Cutting Concerns: Supporting elements like background music,
            special effects, or security checks that enhance the movie but
            aren’t the main plot.
          </li>
          <li class="content-line">
            AOP: The director who seamlessly weaves these elements into the
            movie at the right moments without altering the storyline.
          </li>
          <li class="content-line">
            Proxy: A stunt double who performs special actions for the main
            actor.
          </li>
          <li class="content-line">
            Weaving: The editing process that combines all scenes into a
            cohesive film.
          </li>
        </ul>
      </div>

      <div class="section HLA1" id="benefits">
        <h2 class="section-title">Benefits of AOP</h2>
        <ul>
          <li class="content-line">
            Clean Code: Business logic remains focused, with concerns like
            logging separated.
          </li>
          <li class="content-line">
            Reusability: Aspects can be applied to multiple classes or methods.
          </li>
          <li class="content-line">
            Maintainability: Changes to concerns like logging are made in one
            place (the aspect).
          </li>
          <li class="content-line">
            Non-Invasive: Add new concerns without changing existing code.
          </li>
          <li class="content-line">
            Scalability: Easily extend to new concerns (e.g., caching,
            auditing).
          </li>
        </ul>
      </div>

      <div class="section" id="key-concepts">
        <h2 class="section-title">Key AOP Concepts</h2>
        <p class="content-line">
          Spring AOP introduces several terms that are crucial for understanding
          how it works. Below, each concept is explained with a simple
          definition, a movie analogy, a practical example from a job management
          application, and additional clarifications to address common beginner
          challenges.
        </p>

        <h3 class="subsection-title">Aspect</h3>
        <p class="content-line">
          Definition: A class that encapsulates the code for a cross-cutting
          concern, containing methods (advice) to handle tasks like logging or
          validation.
        </p>
        <p class="content-line">
          Movie Analogy: The crew responsible for a specific task, like the
          sound team adding background music.
        </p>
        <p class="content-line">
          Example: A LoggingAspect class that logs method calls in a job
          management application.
        </p>
        <p class="content-line">
          Clarification: An aspect is a regular Java class annotated with
          @Aspect and @Component, making it a Spring-managed bean. It groups
          related advice methods, so you can organize all logging logic in one
          place, separate from business logic. Beginners often confuse aspects
          with regular classes; think of aspects as specialized classes that
          Spring uses to apply cross-cutting behavior.
        </p>

        <h3 class="subsection-title">Join Point</h3>
        <p class="content-line">
          Definition: A specific point in the program where an aspect can be
          applied, typically a method execution.
        </p>
        <p class="content-line">
          Movie Analogy: A specific scene in the movie where an action (e.g.,
          music) is added.
        </p>
        <p class="content-line">
          Example: The execution of the getJob method in JobService.
        </p>
        <p class="content-line">
          Clarification: Join points are potential points of interception, but
          not all are used. In Spring AOP, join points are usually method
          executions (not field access or object creation, as in AspectJ).
          Beginners should focus on method calls as join points, as they’re the
          most common use case.
        </p>

        <h3 class="subsection-title">Advice</h3>
        <p class="content-line">
          Definition: The action taken by an aspect at a join point, defining
          what to do and when (e.g., log a message before a method runs).
        </p>
        <p class="content-line">
          Movie Analogy: The specific action in a scene, like playing a dramatic
          sound effect.
        </p>
        <p class="content-line">
          Example: Logging a message before getJob executes.
        </p>
        <p class="content-line">
          Clarification: Advice is the actual code that runs, and its type
          (e.g., Before, After) determines its timing. Beginners often struggle
          with choosing the right advice type; start with @Before for simple
          tasks like logging, then explore others as needed.
        </p>

        <h3 class="subsection-title">Pointcut</h3>
        <p class="content-line">
          Definition: An expression that specifies where an advice should be
          applied, selecting specific join points.
        </p>
        <p class="content-line">
          Movie Analogy: The script that says, “Add music to all action scenes.”
        </p>
        <p class="content-line">
          Example: An expression like execution(*
          com.telusko.springmvcboot.service.JobService.*(..)) to apply logging
          to all JobService methods.
        </p>
        <p class="content-line">
          Clarification: Pointcuts use a syntax called AspectJ pointcut
          expressions, which can seem intimidating. The execution keyword is
          common, and wildcards like * (any method or return type) and .. (any
          arguments) make it flexible. Beginners should practice simple
          pointcuts (e.g., targeting one method) before using complex ones.
        </p>

        <h3 class="subsection-title">Target</h3>
        <p class="content-line">
          Definition: The object (class) to which the aspect is applied.
        </p>
        <p class="content-line">
          Movie Analogy: The main actor whose scenes are enhanced by special
          effects.
        </p>
        <p class="content-line">
          Example: The JobService class in the job management application.
        </p>
        <p class="content-line">
          Clarification: The target is the class you’re monitoring or enhancing.
          Spring AOP wraps the target with a proxy to apply aspects, so the
          original class remains unchanged. Beginners should note that only
          Spring-managed beans (e.g., annotated with @Service) can be targets in
          Spring AOP.
        </p>

        <h3 class="subsection-title">Proxy</h3>
        <p class="content-line">
          Definition: A wrapper object created by Spring to intercept calls to
          the target and apply the aspect’s advice.
        </p>
        <p class="content-line">
          Movie Analogy: A stunt double who performs special actions for the
          main actor.
        </p>
        <p class="content-line">
          Example: A proxy for JobService that adds logging before method calls.
        </p>
        <p class="content-line">
          Clarification: Spring AOP uses JDK dynamic proxies (for interfaces) or
          CGLIB proxies (for classes) to create this wrapper. Beginners may find
          proxies confusing; think of them as an invisible layer that adds
          aspect behavior without touching the original code. If a method isn’t
          intercepted, check if the target is a Spring bean.
        </p>

        <h3 class="subsection-title">Weaving</h3>
        <p class="content-line">
          Definition: The process of linking aspects with the target code,
          integrating advice at the specified join points.
        </p>
        <p class="content-line">
          Movie Analogy: The editing process that combines the main storyline
          with special effects.
        </p>
        <p class="content-line">
          Example: Spring weaving the LoggingAspect into JobService method calls
          at runtime.
        </p>
        <p class="content-line">
          Clarification: In Spring AOP, weaving occurs at runtime, meaning the
          aspect’s logic is applied when the application runs, not when the code
          is compiled (unlike AspectJ). This makes Spring AOP lightweight but
          limited to Spring-managed beans. Beginners should focus on runtime
          weaving and avoid worrying about compile-time weaving for now.
        </p>

        <h3 class="subsection-title">Advice Types</h3>
        <p class="content-line">
          Before: Runs before the join point (e.g., log before a method).
        </p>
        <p class="content-line">
          After: Runs after the join point, regardless of success or failure
          (like a finally block).
        </p>
        <p class="content-line">
          After Returning: Runs only if the join point completes successfully.
        </p>
        <p class="content-line">
          After Throwing: Runs if the join point throws an exception.
        </p>
        <p class="content-line">
          Around: Wraps the join point, allowing actions before and after, and
          control over whether the join point executes.
        </p>
        <p class="content-line">
          Clarification: Each advice type serves a specific purpose. @Before and
          @After are straightforward, while @Around is powerful but complex
          because it requires manual control (e.g., calling proceed()).
          Beginners should master @Before and @After before tackling @Around.
        </p>
      </div>

      <div class="section" id="practical-implementation">
        <h2 class="section-title">Practical Implementation with Code</h2>
        <p class="content-line">
          Let’s implement AOP in a job management application, using code
          directly from the provided GitHub repository (<a
            href="https://github.com/navinreddy20/spring6-course/tree/c6690e4f2c70d8f530d70623f13d14ff0ffd7e7d/11%20Spring%20AOP"
            >GitHub</a
          >).
        </p>
        <p class="content-line">
          The application has a JobService class with methods like getJob,
          updateJob, addJob, and getAllJobs.
        </p>
        <p class="content-line">
          We’ll use the LoggingAspect, PerformanceMonitorAspect, and
          ValidationAspect classes from the repository, placing them in
          appropriate sections to demonstrate different advice types.
        </p>
        <p class="content-line">
          Each code snippet includes detailed comments to explain functionality
          and enhance understanding for beginners and intermediate learners.
        </p>

        <h3 class="subsection-title">Setup</h3>
        <p class="content-line">
          Dependencies: Add spring-boot-starter-aop and slf4j to your pom.xml
          for AOP and logging support.
        </p>
        <pre class="code-block">
<span class="xml-element">&lt;dependency&gt;</span>
    <span class="xml-element">&lt;groupId&gt;</span><span class="xml-value">org.springframework.boot</span><span class="xml-element">&lt;/groupId&gt;</span>
    <span class="xml-element">&lt;artifactId&gt;</span><span class="xml-value">spring-boot-starter-aop</span><span class="xml-element">&lt;/artifactId&gt;</span>
<span class="xml-element">&lt;/dependency&gt;</span>
<span class="xml-element">&lt;dependency&gt;</span>
    <span class="xml-element">&lt;groupId&gt;</span><span class="xml-value">org.slf4j</span><span class="xml-element">&lt;/groupId&gt;</span>
    <span class="xml-element">&lt;artifactId&gt;</span><span class="xml-value">slf4j-api</span><span class="xml-element">&lt;/artifactId&gt;</span>
<span class="xml-element">&lt;/dependency&gt;</span>
            </pre>
        <p class="content-line">
          Package Structure: Place aspects in com.telusko.springmvcboot.aop and
          services in com.telusko.springmvcboot.service.
        </p>
        <p class="content-line">
          Tools: Use Postman to test API endpoints and verify logs in the
          console.
        </p>
        <p class="content-line">
          Note: The GitHub code uses the package com.telusko.springmvcboot,
          which differs from the earlier examples (com.co.spring.boot.rest).
          This reflects the repository’s structure.
        </p>

        <h3 class="subsection-title">1. Logging with Before Advice</h3>
        <p class="content-line">
          We use the LoggingAspect from the GitHub repository to log method
          calls in JobService before execution, helping track application
          behavior. This demonstrates the @Before advice.
        </p>
        <pre class="code-block">
<span class="keyword-highlight">package</span> com.telusko.springmvcboot.aop;

<span class="keyword-highlight">import</span> org.aspectj.lang.<span class="class-highlight">JoinPoint</span>;
<span class="keyword-highlight">import</span> org.aspectj.lang.annotation.<span class="class-highlight">After</span>;
<span class="keyword-highlight">import</span> org.aspectj.lang.annotation.<span class="class-highlight">AfterReturning</span>;
<span class="keyword-highlight">import</span> org.aspectj.lang.annotation.<span class="class-highlight">AfterThrowing</span>;
<span class="keyword-highlight">import</span> org.aspectj.lang.annotation.<span class="class-highlight">Aspect</span>;
<span class="keyword-highlight">import</span> org.aspectj.lang.annotation.<span class="class-highlight">Before</span>;
<span class="keyword-highlight">import</span> org.slf4j.<span class="class-highlight">Logger</span>;
<span class="keyword-highlight">import</span> org.slf4j.<span class="class-highlight">LoggerFactory</span>;
<span class="keyword-highlight">import</span> org.springframework.stereotype.<span class="class-highlight">Component</span>;

<span class="comment-highlight">// Mark this class as a Spring-managed bean and an AOP aspect</span>
<span class="annotation-highlight">@Component</span>
<span class="annotation-highlight">@Aspect</span>
<span class="keyword-highlight">public</span> <span class="keyword-highlight">class</span> <span class="class-highlight">LoggingAspect</span> {

    <span class="comment-highlight">// Initialize logger for console/file output</span>
    <span class="keyword-highlight">private</span> <span class="keyword-highlight">static</span> <span class="keyword-highlight">final</span> <span class="class-highlight">Logger</span> logger = <span class="class-highlight">LoggerFactory</span>.getLogger(<span class="class-highlight">LoggingAspect</span>.<span class="keyword-highlight">class</span>);

    <span class="comment-highlight">// Before advice to log method calls before execution</span>
    <span class="comment-highlight">// Pointcut: Targets getJob and updateJob methods in JobService</span>
    <span class="comment-highlight">// * = any return type, .. = any arguments</span>
    <span class="annotation-highlight">@Before</span>(<span class="string-highlight">"execution(* com.telusko.springmvcboot.service.JobService.getJob(..)) || execution(* com.telusko.springmvcboot.service.JobService.updateJob(..))"</span>)
    <span class="keyword-highlight">public</span> <span class="keyword-highlight">void</span> logMethodCall(<span class="class-highlight">JoinPoint</span> jp) {
        <span class="comment-highlight">// Log the method name using JoinPoint to access method details</span>
        logger.info(<span class="string-highlight">"method called "</span> + jp.getSignature().getName());
    }

    <span class="comment-highlight">// [Other advice methods are shown in later sections]</span>
}
            </pre>
        <h4 class="subsection-title">Explanation:</h4>
        <ul>
          <li class="content-line">
            @Component: Registers the class as a Spring bean, allowing Spring to
            manage it.
          </li>
          <li class="content-line">
            @Aspect: Marks the class as an AOP aspect, enabling it to define
            advice.
          </li>
          <li class="content-line">
            @Before: Specifies that the advice runs before the targeted methods
            (getJob and updateJob).
          </li>
          <li class="content-line">
            Pointcut Expression: Combines two expressions with ||:
          </li>
          <li class="content-line">
            execution(*
            com.telusko.springmvcboot.service.JobService.getJob(..)): Targets
            getJob.
          </li>
          <li class="content-line">
            execution(*
            com.telusko.springmvcboot.service.JobService.updateJob(..)): Targets
            updateJob.
          </li>
          <li class="content-line">*: Any return type.</li>
          <li class="content-line">(..): Any number of arguments.</li>
          <li class="content-line">
            JoinPoint: Provides method metadata, with getSignature().getName()
            logging the method name (e.g., getJob).
          </li>
          <li class="content-line">
            Logger: Uses SLF4J to log messages to the console (configurable to a
            file).
          </li>
          <li class="content-line">
            Why It’s Useful: Automatically logs method calls without adding
            logger.info statements to JobService, keeping the service code
            clean.
          </li>
        </ul>
        <p class="content-line">
          Real-World Example: In a job portal, logging tracks when users view a
          job (getJob) or update a job listing (updateJob), helping debug issues
          if users report errors (e.g., “I can’t view job ID 5”).
        </p>
        <p class="content-line">
          Testing: Send a Postman GET request to /jobs/1 (calls getJob). The
          console logs: <span class="highlight">method called getJob</span>.
          Send a PUT request to /jobs/1 (calls updateJob), and it logs:
          <span class="highlight">method called updateJob</span>.
        </p>
        <p class="content-line">
          Common Pitfall: If logs don’t appear, ensure:
        </p>
        <ul>
          <li class="content-line">
            JobService is annotated with @Service and is a Spring bean.
          </li>
          <li class="content-line">
            The pointcut matches the method signatures (check package and method
            names).
          </li>
          <li class="content-line">
            The AOP dependency is included in pom.xml.
          </li>
        </ul>

        <h3 class="subsection-title">
          2. Logging Specific Methods with JoinPoint
        </h3>
        <p class="content-line">
          To enhance logging, we can use the same logMethodCall method and
          pointcut from LoggingAspect to demonstrate how JoinPoint provides
          access to method details.
        </p>
        <p class="content-line">
          The code above already logs the method name, but let’s highlight its
          use with JoinPoint.
        </p>
        <h4 class="subsection-title">Explanation:</h4>
        <ul>
          <li class="content-line">
            JoinPoint Usage: The jp.getSignature().getName() call retrieves the
            method name (getJob or updateJob). JoinPoint also supports:
          </li>
          <li class="content-line">
            jp.getArgs(): To log arguments (e.g., postId for getJob).
          </li>
          <li class="content-line">
            jp.getTarget(): To log the target object (e.g., JobService
            instance).
          </li>
          <li class="content-line">
            Pointcut Specificity: The pointcut targets only getJob and
            updateJob, reducing log noise compared to targeting all JobService
            methods.
          </li>
          <li class="content-line">
            Output: For /jobs/1, logs:
            <span class="highlight">method called getJob</span>. For a PUT to
            /jobs/1, logs:
            <span class="highlight">method called updateJob</span>.
          </li>
          <li class="content-line">
            Why It’s Useful: Logging specific methods with details like method
            names or arguments helps debug critical operations without
            cluttering logs.
          </li>
        </ul>
        <p class="content-line">
          Real-World Example: In a job portal, logging getJob calls with their
          postId helps track which job listings are viewed, aiding in diagnosing
          user-reported issues (e.g., “I can’t view job ID 5”). Adding
          jp.getArgs() could log the postId (e.g.,
          <span class="highlight">Arguments: [5]</span>).
        </p>
        <p class="content-line">
          Testing: Same as above. To log arguments, modify the method to:
        </p>
        <pre class="code-block">
<span class="annotation-highlight">@Before</span>(<span class="string-highlight">"execution(* com.telusko.springmvcboot.service.JobService.getJob(..)) || execution(* com.telusko.springmvcboot.service.JobService.updateJob(..))"</span>)
<span class="keyword-highlight">public</span> <span class="keyword-highlight">void</span> logMethodCall(<span class="class-highlight">JoinPoint</span> jp) {
    logger.info(<span class="string-highlight">"method called {} with arguments {}"</span>, 
                jp.getSignature().getName(), 
                <span class="class-highlight">Arrays</span>.toString(jp.getArgs()));
}
            </pre>
        <p class="content-line">
          Output: For /jobs/1, logs:
          <span class="highlight">method called getJob with arguments [1]</span
          >.
        </p>
        <p class="content-line">
          Additional Insight: Beginners can experiment with JoinPoint methods
          like getArgs() or getTarget() to log more details. Start with
          getSignature().getName() for simplicity, then explore others as
          needed.
        </p>

        <h3 class="subsection-title">3. After Advice Types</h3>
        <p class="content-line">
          The LoggingAspect from the GitHub repository includes @After,
          @AfterReturning, and @AfterThrowing advice to handle different
          outcomes of getJob and updateJob.
        </p>
        <pre class="code-block">
<span class="keyword-highlight">package</span> com.telusko.springmvcboot.aop;

<span class="keyword-highlight">import</span> org.aspectj.lang.<span class="class-highlight">JoinPoint</span>;
<span class="keyword-highlight">import</span> org.aspectj.lang.annotation.<span class="class-highlight">After</span>;
<span class="keyword-highlight">import</span> org.aspectj.lang.annotation.<span class="class-highlight">AfterReturning</span>;
<span class="keyword-highlight">import</span> org.aspectj.lang.annotation.<span class="class-highlight">AfterThrowing</span>;
<span class="keyword-highlight">import</span> org.aspectj.lang.annotation.<span class="class-highlight">Aspect</span>;
<span class="keyword-highlight">import</span> org.aspectj.lang.annotation.<span class="class-highlight">Before</span>;
<span class="keyword-highlight">import</span> org.slf4j.<span class="class-highlight">Logger</span>;
<span class="keyword-highlight">import</span> org.slf4j.<span class="class-highlight">LoggerFactory</span>;
<span class="keyword-highlight">import</span> org.springframework.stereotype.<span class="class-highlight">Component</span>;

<span class="comment-highlight">// Mark this class as a Spring-managed bean and an AOP aspect</span>
<span class="annotation-highlight">@Component</span>
<span class="annotation-highlight">@Aspect</span>
<span class="keyword-highlight">public</span> <span class="keyword-highlight">class</span> <span class="class-highlight">LoggingAspect</span> {

    <span class="comment-highlight">// Initialize logger for console/file output</span>
    <span class="keyword-highlight">private</span> <span class="keyword-highlight">static</span> <span class="keyword-highlight">final</span> <span class="class-highlight">Logger</span> logger = <span class="class-highlight">LoggerFactory</span>.getLogger(<span class="class-highlight">LoggingAspect</span>.<span class="keyword-highlight">class</span>);

    <span class="comment-highlight">// Before advice (shown above)</span>
    <span class="annotation-highlight">@Before</span>(<span class="string-highlight">"execution(* com.telusko.springmvcboot.service.JobService.getJob(..)) || execution(* com.telusko.springmvcboot.service.JobService.updateJob(..))"</span>)
    <span class="keyword-highlight">public</span> <span class="keyword-highlight">void</span> logMethodCall(<span class="class-highlight">JoinPoint</span> jp) {
        logger.info(<span class="string-highlight">"method called "</span> + jp.getSignature().getName());
    }

    <span class="comment-highlight">// After advice (runs after method completion, like finally)</span>
    <span class="comment-highlight">// Pointcut: Targets getJob and updateJob methods</span>
    <span class="annotation-highlight">@After</span>(<span class="string-highlight">"execution(* com.telusko.springmvcboot.service.JobService.getJob(..)) || execution(* com.telusko.springmvcboot.service.JobService.updateJob(..))"</span>)
    <span class="keyword-highlight">public</span> <span class="keyword-highlight">void</span> logMethodExecuted(<span class="class-highlight">JoinPoint</span> jp) {
        <span class="comment-highlight">// Log that the method has completed, regardless of success or failure</span>
        logger.info(<span class="string-highlight">"method executed "</span> + jp.getSignature().getName());
    }

    <span class="comment-highlight">// AfterReturning advice (runs after successful execution)</span>
    <span class="comment-highlight">// Pointcut: Targets getJob and updateJob methods</span>
    <span class="annotation-highlight">@AfterReturning</span>(<span class="string-highlight">"execution(* com.telusko.springmvcboot.service.JobService.getJob(..)) || execution(* com.telusko.springmvcboot.service.JobService.updateJob(..))"</span>)
    <span class="keyword-highlight">public</span> <span class="keyword-highlight">void</span> logMethodSuccess(<span class="class-highlight">JoinPoint</span> jp) {
        <span class="comment-highlight">// Log when the method completes without throwing an exception</span>
        logger.info(<span class="string-highlight">"method executed successfully "</span> + jp.getSignature().getName());
    }

    <span class="comment-highlight">// AfterThrowing advice (runs if method throws an exception)</span>
    <span class="comment-highlight">// Pointcut: Targets getJob and updateJob methods</span>
    <span class="annotation-highlight">@AfterThrowing</span>(<span class="string-highlight">"execution(* com.telusko.springmvcboot.service.JobService.getJob(..)) || execution(* com.telusko.springmvcboot.service.JobService.updateJob(..))"</span>)
    <span class="keyword-highlight">public</span> <span class="keyword-highlight">void</span> logMethodCrash(<span class="class-highlight">JoinPoint</span> jp) {
        <span class="comment-highlight">// Log when the method fails due to an exception</span>
        logger.info(<span class="string-highlight">"method has some issues "</span> + jp.getSignature().getName());
    }
}
            </pre>
        <h4 class="subsection-title">Explanation:</h4>
        <ul>
          <li class="content-line">
            @After: Runs after the method, regardless of outcome (success or
            failure), similar to a finally block. Useful for logging completion
            or cleanup.
          </li>
          <li class="content-line">
            @AfterReturning: Runs only if the method completes without throwing
            an exception. Ideal for logging successful operations.
          </li>
          <li class="content-line">
            @AfterThrowing: Runs only if the method throws an exception. Perfect
            for error logging and debugging.
          </li>
          <li class="content-line">
            Pointcut: Uses || to target both getJob and updateJob, combining
            expressions for efficiency.
          </li>
          <li class="content-line">
            JoinPoint: Logs the method name for context.
          </li>
          <li class="content-line">
            Why It’s Useful: These advice types allow precise monitoring of
            method outcomes, helping developers understand application behavior
            without modifying JobService.
          </li>
        </ul>
        <p class="content-line">
          Real-World Example: In a banking application, @AfterReturning logs
          successful transactions (e.g., “Transfer completed”), @AfterThrowing
          logs failures (e.g., “Insufficient funds”), and @After logs that the
          transaction attempt was processed, regardless of outcome.
        </p>
        <p class="content-line">Testing:</p>
        <ul>
          <li class="content-line">
            Normal Request: Send a Postman GET request to /jobs/1. Logs:
          </li>
          <li class="content-line">
            <span class="highlight">method called getJob</span>
          </li>
          <li class="content-line">
            <span class="highlight">method executed successfully getJob</span>
          </li>
          <li class="content-line">
            <span class="highlight">method executed getJob</span>
          </li>
          <li class="content-line">
            Exception Case: Modify getJob to throw an exception (e.g., int x =
            10/0;). Request /jobs/1 logs:
          </li>
          <li class="content-line">
            <span class="highlight">method called getJob</span>
          </li>
          <li class="content-line">
            <span class="highlight">method has some issues getJob</span>
          </li>
          <li class="content-line">
            <span class="highlight">method executed getJob</span>
          </li>
          <li class="content-line">
            Note: <span class="highlight">method executed successfully</span> is
            skipped because the method failed.
          </li>
        </ul>
        <p class="content-line">
          Common Pitfall: If @AfterThrowing doesn’t trigger, ensure the
          exception isn’t caught within getJob (AOP only detects unhandled
          exceptions). Verify the pointcut matches the method signature.
        </p>
        <p class="content-line">
          Additional Insight: @AfterReturning can capture the method’s return
          value using @AfterReturning(returning="result") and a parameter like
          public void logMethodSuccess(JoinPoint jp, Object result). This is
          useful for logging outputs (e.g., the returned Job object), but keep
          it simple for beginners.
        </p>

        <h3 class="subsection-title">
          4. Performance Monitoring with Around Advice
        </h3>
        <p class="content-line">
          We use the PerformanceMonitorAspect from the GitHub repository to
          measure the execution time of JobService methods, demonstrating the
          @Around advice.
        </p>
        <pre class="code-block">
<span class="keyword-highlight">package</span> com.telusko.springmvcboot.aop;

<span class="keyword-highlight">import</span> org.aspectj.lang.<span class="class-highlight">ProceedingJoinPoint</span>;
<span class="keyword-highlight">import</span> org.aspectj.lang.annotation.<span class="class-highlight">Around</span>;
<span class="keyword-highlight">import</span> org.aspectj.lang.annotation.<span class="class-highlight">Aspect</span>;
<span class="keyword-highlight">import</span> org.slf4j.<span class="class-highlight">Logger</span>;
<span class="keyword-highlight">import</span> org.slf4j.<span class="class-highlight">LoggerFactory</span>;
<span class="keyword-highlight">import</span> org.springframework.stereotype.<span class="class-highlight">Component</span>;

<span class="comment-highlight">// Mark as a Spring-managed bean and AOP aspect</span>
<span class="annotation-highlight">@Component</span>
<span class="annotation-highlight">@Aspect</span>
<span class="keyword-highlight">public</span> <span class="keyword-highlight">class</span> <span class="class-highlight">PerformanceMonitorAspect</span> {

    <span class="comment-highlight">// Initialize logger for console/file output</span>
    <span class="keyword-highlight">private</span> <span class="keyword-highlight">static</span> <span class="keyword-highlight">final</span> <span class="class-highlight">Logger</span> logger = <span class="class-highlight">LoggerFactory</span>.getLogger(<span class="class-highlight">PerformanceMonitorAspect</span>.<span class="keyword-highlight">class</span>);

    <span class="comment-highlight">// Around advice to measure execution time</span>
    <span class="comment-highlight">// Pointcut: Targets all methods in JobService</span>
    <span class="comment-highlight">// * = any return type, .* = any method, .. = any arguments</span>
    <span class="annotation-highlight">@Around</span>(<span class="string-highlight">"execution(* com.telusko.springmvcboot.service.JobService.*(..))"</span>)
    <span class="keyword-highlight">public</span> <span class="class-highlight">Object</span> monitorTime(<span class="class-highlight">ProceedingJoinPoint</span> jp) <span class="keyword-highlight">throws</span> <span class="class-highlight">Throwable</span> {
        <span class="comment-highlight">// Record start time in milliseconds</span>
        <span class="keyword-highlight">long</span> start = <span class="class-highlight">System</span>.currentTimeMillis();

        <span class="comment-highlight">// Execute the target method and capture its result</span>
        <span class="class-highlight">Object</span> obj = jp.proceed();

        <span class="comment-highlight">// Record end time and calculate duration</span>
        <span class="keyword-highlight">long</span> end = <span class="class-highlight">System</span>.currentTimeMillis();

        <span class="comment-highlight">// Log method name and execution time</span>
        logger.info(<span class="string-highlight">"Time taken by "</span> + jp.getSignature().getName() + <span class="string-highlight">" : "</span> + (end - start) + <span class="string-highlight">" milliseconds"</span>);

        <span class="comment-highlight">// Return the method's result to ensure normal application flow</span>
        <span class="keyword-highlight">return</span> obj;
    }
}
            </pre>
        <h4 class="subsection-title">Explanation:</h4>
        <ul>
          <li class="content-line">
            @Around: Allows actions before and after the method, giving full
            control over execution.
          </li>
          <li class="content-line">
            ProceedingJoinPoint: Extends JoinPoint, adding the proceed() method
            to invoke the target method (e.g., getJob).
          </li>
          <li class="content-line">
            Time Measurement: Uses System.currentTimeMillis() to capture start
            and end times, calculating the difference.
          </li>
          <li class="content-line">
            jp.proceed(): Calls the target method. Omitting this prevents the
            method from executing, breaking the application.
          </li>
          <li class="content-line">
            Return: @Around must return the result of proceed() to maintain
            normal application behavior.
          </li>
          <li class="content-line">
            Pointcut: Targets all JobService methods (.*) for comprehensive
            monitoring.
          </li>
          <li class="content-line">
            Why It’s Useful: Measuring execution time identifies slow methods,
            critical for optimizing performance in production.
          </li>
        </ul>
        <p class="content-line">
          Real-World Example: In an e-commerce application, monitoring the
          checkout method’s execution time ensures a fast user experience. If
          logs show checkout takes 500ms, developers can optimize database
          queries or caching.
        </p>
        <p class="content-line">
          Testing: Send a Postman GET request to /jobs/1. Logs:
          <span class="highlight">Time taken by getJob : 97 milliseconds</span>.
          For /jobs, logs:
          <span class="highlight"
            >Time taken by getAllJobs : 79 milliseconds</span
          >. Repeated requests may show reduced times due to caching.
        </p>
        <p class="content-line">
          Common Pitfall: Forgetting jp.proceed() or the return statement in
          @Around causes the application to hang or return null. If execution
          times are zero, ensure the method involves actual work (e.g., database
          calls). Verify the pointcut targets the correct methods.
        </p>
        <p class="content-line">
          Additional Insight: @Around is versatile and can:
        </p>
        <ul>
          <li class="content-line">
            Skip the target method (e.g., return cached data).
          </li>
          <li class="content-line">
            Modify inputs/outputs (see validation example).
          </li>
          <li class="content-line">
            Handle exceptions (wrap proceed() in a try-catch). Beginners should
            use @Around after mastering @Before and @After, as it requires
            careful handling.
          </li>
        </ul>

        <h3 class="subsection-title">5. Input Validation with Around Advice</h3>
        <p class="content-line">
          We use the ValidationAspect from the GitHub repository to validate and
          update inputs for the getJob method, ensuring negative postId values
          are corrected.
        </p>
        <pre class="code-block">
<span class="keyword-highlight">package</span> com.telusko.springmvcboot.aop;

<span class="keyword-highlight">import</span> org.aspectj.lang.<span class="class-highlight">ProceedingJoinPoint</span>;
<span class="keyword-highlight">import</span> org.aspectj.lang.annotation.<span class="class-highlight">Around</span>;
<span class="keyword-highlight">import</span> org.aspectj.lang.annotation.<span class="class-highlight">Aspect</span>;
<span class="keyword-highlight">import</span> org.slf4j.<span class="class-highlight">Logger</span>;
<span class="keyword-highlight">import</span> org.slf4j.<span class="class-highlight">LoggerFactory</span>;
<span class="keyword-highlight">import</span> org.springframework.stereotype.<span class="class-highlight">Component</span>;

<span class="comment-highlight">// Mark as a Spring-managed bean and AOP aspect</span>
<span class="annotation-highlight">@Component</span>
<span class="annotation-highlight">@Aspect</span>
<span class="keyword-highlight">public</span> <span class="keyword-highlight">class</span> <span class="class-highlight">ValidationAspect</span> {

    <span class="comment-highlight">// Initialize logger for console/file output</span>
    <span class="keyword-highlight">private</span> <span class="keyword-highlight">static</span> <span class="keyword-highlight">final</span> <span class="class-highlight">Logger</span> logger = <span class="class-highlight">LoggerFactory</span>.getLogger(<span class="class-highlight">ValidationAspect</span>.<span class="keyword-highlight">class</span>);

    <span class="comment-highlight">// Around advice to validate and update input</span>
    <span class="comment-highlight">// Pointcut: Targets getJob and captures postId argument</span>
    <span class="comment-highlight">// args(postId) binds the method's argument to the postId parameter</span>
    <span class="annotation-highlight">@Around</span>(<span class="string-highlight">"execution(* com.telusko.springmvcboot.service.JobService.getJob(..)) && args(postId)"</span>)
    <span class="keyword-highlight">public</span> <span class="class-highlight">Object</span> validateAndUpdate(<span class="class-highlight">ProceedingJoinPoint</span> jp, <span class="class-highlight">Long</span> postId) <span class="keyword-highlight">throws</span> <span class="class-highlight">Throwable</span> {
        <span class="comment-highlight">// Check if postId is negative</span>
        <span class="keyword-highlight">if</span> (postId < 0) {
            <span class="comment-highlight">// Convert to positive value (e.g., -4 becomes 4)</span>
            postId = -postId;
            <span class="comment-highlight">// Log the update for debugging and audit purposes</span>
            logger.info(<span class="string-highlight">"postId is negative updating to new value "</span> + postId);
        }

        <span class="comment-highlight">// Call the target method with the updated argument</span>
        <span class="class-highlight">Object</span> obj = jp.proceed(<span class="keyword-highlight">new</span> <span class="class-highlight">Object</span>[] { postId });

        <span class="comment-highlight">// Return the method's result to ensure normal application flow</span>
        <span class="keyword-highlight">return</span> obj;
    }
}
            </pre>
        <h4 class="subsection-title">Explanation:</h4>
        <ul>
          <li class="content-line">
            Pointcut with args: execution(*
            com.telusko.springmvcboot.service.JobService.getJob(..)) &&
            args(postId):
          </li>
          <li class="content-line">Targets getJob.</li>
          <li class="content-line">
            && args(postId) binds the method’s postId parameter to the advice’s
            postId parameter.
          </li>
          <li class="content-line">
            Validation Logic: Checks if postId is negative and converts it to
            positive (e.g., -4 to 4).
          </li>
          <li class="content-line">
            jp.proceed(new Object[]{postId}): Calls getJob with the updated
            postId, ensuring the method receives the corrected value.
          </li>
          <li class="content-line">
            Return: Returns the result of proceed() to maintain application
            flow.
          </li>
          <li class="content-line">
            Logging: Logs the update to track validation actions.
          </li>
          <li class="content-line">
            Why It’s Useful: Validates inputs before they reach the business
            logic, preventing errors without modifying JobService.
          </li>
        </ul>
        <p class="content-line">
          Real-World Example: In a ticketing system, a negative ticket ID (e.g.,
          -4) is invalid. The aspect corrects it to 4, ensuring the request
          processes correctly and logging the correction for audit purposes.
        </p>
        <p class="content-line">
          Testing: Send a Postman GET request to /jobs/-4. The request processes
          as if it were /jobs/4, returning the job data. Console logs:
          <span class="highlight"
            >postId is negative updating to new value 4</span
          >. For /jobs/4, no validation log appears, as postId is positive.
        </p>
        <p class="content-line">
          Common Pitfall: If proceed(new Object[]{postId}) uses the wrong
          argument type (e.g., Integer instead of Long), a type mismatch
          exception occurs. Ensure the argument type matches getJob’s signature
          (e.g., public Job getJob(Long postId)). Verify the args(postId) name
          matches the method parameter.
        </p>
        <p class="content-line">
          Additional Insight: @Around for validation is powerful because it can:
        </p>
        <ul>
          <li class="content-line">Modify inputs (as shown).</li>
          <li class="content-line">
            Block execution (e.g., throw an exception for invalid inputs).
          </li>
          <li class="content-line">
            Modify outputs (e.g., format the returned Job object). For simpler
            validation, @Before can check inputs and throw exceptions, but
            @Around is needed for input modification. Test with one parameter
            before handling multiple arguments.
          </li>
        </ul>
      </div>

      <div class="section" id="additional-explanations">
        <h2 class="section-title">Additional Explanations for Clarity</h2>

        <h3 class="subsection-title">Understanding Pointcut Expressions</h3>
        <p class="content-line">
          Pointcut expressions are critical but can be daunting for beginners.
          The execution syntax follows:
        </p>
        <p class="content-line">
          execution(modifiers return-type package.class.method(arguments))
        </p>
        <ul>
          <li class="content-line">
            Modifiers: Optional (e.g., public, * for any).
          </li>
          <li class="content-line">
            Return-type: * for any, or specific (e.g., void, Job).
          </li>
          <li class="content-line">
            Package.Class: Fully qualified name or wildcards (e.g.,
            com.telusko.springmvcboot.service.* for all classes in the package).
          </li>
          <li class="content-line">
            Method: * for any, or specific (e.g., getJob).
          </li>
          <li class="content-line">
            Arguments: .. for any, or specific types (e.g., (Long)).
          </li>
        </ul>
        <h4 class="subsection-title">Example Breakdown:</h4>
        <ul>
          <li class="content-line">
            execution(*
            com.telusko.springmvcboot.service.JobService.getJob(..)):
          </li>
          <li class="content-line">*: Any return type.</li>
          <li class="content-line">
            com.telusko.springmvcboot.service.JobService: Targets JobService.
          </li>
          <li class="content-line">getJob: Specific method.</li>
          <li class="content-line">(..): Any arguments.</li>
          <li class="content-line">
            execution(* com.telusko.springmvcboot.service.*.*(..)):
          </li>
          <li class="content-line">
            Targets all methods in all classes in the service package.
          </li>
        </ul>
        <p class="content-line">
          Tip: Start with specific pointcuts (e.g., one method) to avoid
          applying advice to unintended methods. Use tools like Spring’s
          documentation or IDE auto-completion to validate expressions.
        </p>

        <h3 class="subsection-title">Proxies and Spring Beans</h3>
        <p class="content-line">
          Spring AOP only works with Spring-managed beans (e.g., classes
          annotated with @Service, @Component, @Repository).
        </p>
        <p class="content-line">
          If JobService isn’t a bean, AOP won’t intercept its methods. This is a
          common beginner mistake.
        </p>
        <p class="content-line">To fix:</p>
        <ul>
          <li class="content-line">Annotate JobService with @Service.</li>
          <li class="content-line">
            Ensure the class is in a package scanned by Spring (e.g., under
            com.telusko.springmvcboot).
          </li>
          <li class="content-line">
            Use dependency injection to access JobService, not new JobService().
          </li>
        </ul>
        <p class="content-line">
          Why Proxies Matter: The proxy intercepts calls to JobService,
          executing advice before/after the method.
        </p>
        <p class="content-line">
          If a method calls another method within the same class (e.g., getJob
          calling updateJob), the proxy is bypassed, and advice won’t run
          (self-invocation limitation).
        </p>
        <p class="content-line">
          Workarounds include injecting the service into itself or using AspectJ
          (advanced).
        </p>

        <h3 class="subsection-title">
          Runtime Weaving vs. Compile-Time Weaving
        </h3>
        <p class="content-line">
          Spring AOP uses runtime weaving, applying aspects when the application
          runs via proxies.
        </p>
        <p class="content-line">
          This is lightweight but limited to Spring beans.
        </p>
        <p class="content-line">
          AspectJ supports compile-time weaving, modifying bytecode during
          compilation, allowing broader use cases (e.g., non-Spring classes).
        </p>
        <p class="content-line">
          Beginners should stick to Spring AOP for simplicity, as it integrates
          seamlessly with Spring Boot.
        </p>

        <h3 class="subsection-title">Choosing the Right Advice Type</h3>
        <ul>
          <li class="content-line">
            @Before: Use for setup tasks (e.g., logging, authentication).
          </li>
          <li class="content-line">
            @After: Use for cleanup or logging completion (e.g., “Method
            finished”).
          </li>
          <li class="content-line">
            @AfterReturning: Use to log or process successful results (e.g.,
            “Job retrieved”).
          </li>
          <li class="content-line">
            @AfterThrowing: Use for error handling (e.g., log exceptions).
          </li>
          <li class="content-line">
            @Around: Use for complex scenarios like performance monitoring,
            input/output modification, or conditional execution.
          </li>
        </ul>
        <p class="content-line">
          Decision Tip: If you only need to log or check something before a
          method, use @Before. If you need to manipulate inputs/outputs or
          control execution, use @Around. Test each advice type with a small
          scope to understand its behavior.
        </p>

        <h3 class="subsection-title">Debugging AOP Issues</h3>
        <p class="content-line">Common issues and solutions:</p>
        <ul>
          <li class="content-line">Advice Not Triggering:</li>
          <li class="content-line">
            Check if JobService is a Spring bean (@Service).
          </li>
          <li class="content-line">
            Verify the pointcut (e.g., correct package
            com.telusko.springmvcboot.service).
          </li>
          <li class="content-line">Ensure the AOP dependency is in pom.xml.</li>
          <li class="content-line">Incorrect Logs:</li>
          <li class="content-line">
            Check if the pointcut is too broad (e.g., *.*(..) applies to all
            classes).
          </li>
          <li class="content-line">
            Use JoinPoint to log method details for clarity.
          </li>
          <li class="content-line">@Around Issues:</li>
          <li class="content-line">Ensure proceed() is called.</li>
          <li class="content-line">Return the result from proceed().</li>
          <li class="content-line">
            Match argument types in proceed(new Object[]{}).
          </li>
        </ul>
        <p class="content-line">
          Debugging Tip: Add temporary logger.info statements in the advice to
          trace execution. Use Postman to trigger endpoints (e.g., /jobs/1) and
          check console logs.
        </p>
      </div>

      <div class="section" id="benefits-revisited">
        <h2 class="section-title">Benefits of Spring AOP</h2>
        <ul>
          <li class="content-line">
            Clean Code: Business logic remains focused, with concerns like
            logging separated.
          </li>
          <li class="content-line">
            Reusability: Aspects can be applied to multiple classes or methods.
          </li>
          <li class="content-line">
            Maintainability: Update logging or validation in one place (the
            aspect).
          </li>
          <li class="content-line">
            Non-Invasive: Add new concerns without changing existing code.
          </li>
          <li class="content-line">
            Scalability: Easily extend to new concerns (e.g., caching,
            auditing).
          </li>
        </ul>
      </div>

      <div class="section" id="common-use-cases">
        <h2 class="section-title">Common Use Cases</h2>
        <ul>
          <li class="content-line">
            Logging: Track method calls and errors in a job portal.
          </li>
          <li class="content-line">
            Security: Verify user permissions before accessing sensitive
            methods.
          </li>
          <li class="content-line">
            Performance Monitoring: Measure API response times for optimization.
          </li>
          <li class="content-line">
            Input Validation: Ensure valid data for database queries.
          </li>
          <li class="content-line">
            Exception Handling: Centralize error logging and recovery.
          </li>
          <li class="content-line">
            Caching: Return cached results to avoid redundant database calls.
          </li>
        </ul>
      </div>

      <div class="section" id="tips-for-beginners">
        <h2 class="section-title">Tips for Beginners</h2>
        <ul>
          <li class="content-line">
            Start Simple: Create a @Before aspect for logging one method to
            understand pointcuts and advice.
          </li>
          <li class="content-line">
            Test Incrementally: Use Postman to trigger endpoints and check logs
            after each change.
          </li>
          <li class="content-line">
            Validate Pointcuts: Use specific pointcuts (e.g., getJob) to avoid
            unintended advice application.
          </li>
          <li class="content-line">
            Explore JoinPoint: Log method names, arguments, or target details to
            learn its capabilities.
          </li>
          <li class="content-line">
            Refer to Resources: Check Spring’s AOP documentation (<a
              href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop"
              >Spring Docs</a
            >) and the GitHub repository for working examples.
          </li>
          <li class="content-line">
            Experiment: Clone the GitHub repo, run the application, and modify
            aspects to see their impact.
          </li>
        </ul>
      </div>

      <div class="section" id="conclusion">
        <h2 class="section-title">Conclusion</h2>
        <p class="content-line">
          Spring AOP is a transformative tool for managing cross-cutting
          concerns, making your code cleaner, more maintainable, and easier to
          scale.
        </p>
        <p class="content-line">
          By modularizing tasks like logging, performance monitoring, and input
          validation, you can keep business logic focused while handling
          auxiliary tasks in separate aspects.
        </p>
        <p class="content-line">
          The code examples, sourced from the provided GitHub repository and
          inspired by Telusko’s practical approach, demonstrate how to implement
          AOP in a job management application.
        </p>
        <p class="content-line">
          Each example includes detailed comments to clarify functionality and
          address common beginner challenges.
        </p>
        <p class="content-line">
          Practice with these examples, explore the GitHub repository (<a
            href="https://github.com/navinreddy20/spring6-course/tree/c6690e4f2c70d8f530d70623f13d14ff0ffd7e7d/11%20Spring%20AOP"
            >GitHub</a
          >), and apply AOP to your projects to experience its benefits
          firsthand.
        </p>
        <p class="content-line">
          Start with simple aspects, test thoroughly, and gradually tackle
          advanced features like @Around to build robust, maintainable
          applications.
        </p>
      </div>
    </div>

    <script>
      function changeBackground() {
        const select = document.getElementById("bg-select");
        const body = document.body;
        body.className = select.value;
      }
    </script>
  </body>
</html>
